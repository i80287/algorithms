#include <algorithm>
#include <bitset>
#include <cassert>
#include <cstddef>
#include <cstdint>
#include <random>

#include "../misc/config_macros.hpp"
#include "../misc/test_tools.hpp"
#include "bitmatrix.hpp"

// clang-format off
// NOLINTBEGIN(cert-dcl03-c, misc-static-assert, hicpp-static-assert, cppcoreguidelines-avoid-magic-numbers)
// NOLINTBEGIN(cppcoreguidelines-avoid-c-arrays, hicpp-avoid-c-arrays, modernize-avoid-c-arrays)
// clang-format on

namespace {

#if CONFIG_HAS_AT_LEAST_CXX_20
#define CONSTEXPR_IF_AT_LEAST_CXX_20 constexpr
#else
#define CONSTEXPR_IF_AT_LEAST_CXX_20 inline
#endif

ATTRIBUTE_NODISCARD_WITH_MESSAGE("test returns true on success and false otherwise")
ATTRIBUTE_CONST
CONSTEXPR_IF_AT_LEAST_CXX_20 bool test_transpose_8x8() noexcept {
    // clang-format off
    CStyleMatrix8x8 a = {
        0b00011000,
        0b00011000,
        0b11111111,
        0b01101110,
        0b01100111,
        0b11111111,
        0b00011000,
        0b10011000,
    };
    constexpr CStyleMatrix8x8 a_tr_1 = {
        0b00110100,
        0b00111100,
        0b00111100,
        0b11101111,
        0b11100111,
        0b00111100,
        0b00111100,
        0b10100100,
    };
    constexpr CStyleMatrix8x8 a_tr_2 = {
        0b00100101,
        0b00111100,
        0b00111100,
        0b11100111,
        0b11110111,
        0b00111100,
        0b00111100,
        0b00101100,
    };
    static_assert(sizeof(a) == sizeof(a_tr_1));
    static_assert(sizeof(a) == sizeof(a_tr_2));

    transpose8(a);
    if (!std::equal(&a[0], &a[8], &a_tr_1[0])) {
        return false;
    }

    // return 'a' to initial state
    transpose8(a);

    transpose8</*AgainstMinorDiagonal = */ true>(a);
    if (!std::equal(&a[0], &a[8], &a_tr_2[0])) {
        return false;
    }

    if (!config::is_constant_evaluated()) {
        Matrix8x8 b = {
            0b00001111,
            0b00000000,
            0b00001111,
            0b00000000,
            0b00001111,
            0b00000000,
            0b00001111,
            0b00000000,
        };
        constexpr Matrix8x8 b_tr_1 = {
            0b01010101,
            0b01010101,
            0b01010101,
            0b01010101,
            0b00000000,
            0b00000000,
            0b00000000,
            0b00000000,
        };
        constexpr Matrix8x8 b_tr_2 = {
            0b00000000,
            0b00000000,
            0b00000000,
            0b00000000,
            0b10101010,
            0b10101010,
            0b10101010,
            0b10101010,
        };
        static_assert(sizeof(b) == sizeof(b_tr_1));
        static_assert(sizeof(b) == sizeof(b_tr_2));

        transpose8(b);
        if (!std::equal(b.begin(), b.end(), b_tr_1.begin())) {
            return false;
        }

        // return 'b' to initial state
        transpose8(b);

        transpose8</*AgainstMinorDiagonal = */ true>(b);

        // clang-format on
        if (!std::equal(b.begin(), b.end(), b_tr_2.begin())) {
            return false;
        }
    }

    return true;
}

ATTRIBUTE_NODISCARD_WITH_MESSAGE("test returns true on success and false otherwise")
ATTRIBUTE_CONST
CONSTEXPR_IF_AT_LEAST_CXX_20 bool test_transpose_32x32() noexcept {
    // clang-format off
    CStyleMatrix32x32 a = {
        0b00011000000000000000000000000001U,
        0b00011000000000000000000000000010U,
        0b11111111000000000000000000001100U,
        0b01101110000000000000000000000000U,
        0b01100111000000000000000000000000U,
        0b11111111000000000000000000000000U,
        0b00011000000000000000000000000000U,
        0b00011000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
    };
    constexpr CStyleMatrix32x32 a_tr_1 = {
        0b00000000000000000000000000000001U,
        0b00000000000000000000000000000010U,
        0b00000000000000000000000000000100U,
        0b00000000000000000000000000000100U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000110100U,
        0b00000000000000000000000000111100U,
        0b00000000000000000000000000111100U,
        0b00000000000000000000000011101111U,
        0b00000000000000000000000011100111U,
        0b00000000000000000000000000111100U,
        0b00000000000000000000000000111100U,
        0b00000000000000000000000000100100U,
    };
    constexpr CStyleMatrix32x32 a_tr_2 = {
        0b00100100000000000000000000000000U,
        0b00111100000000000000000000000000U,
        0b00111100000000000000000000000000U,
        0b11100111000000000000000000000000U,
        0b11110111000000000000000000000000U,
        0b00111100000000000000000000000000U,
        0b00111100000000000000000000000000U,
        0b00101100000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00100000000000000000000000000000U,
        0b00100000000000000000000000000000U,
        0b01000000000000000000000000000000U,
        0b10000000000000000000000000000000U,
    };
    // clang-format on
    static_assert(sizeof(a) == sizeof(a_tr_1));
    static_assert(sizeof(a) == sizeof(a_tr_2));

    transpose32(a);
    const bool f1 = std::equal(&a[0], &a[32], &a_tr_1[0]);

    // return 'a' to initial state
    transpose32(a);

    transpose32<true>(a);
    const bool f2 = std::equal(&a[0], &a[32], &a_tr_2[0]);

    return f1 && f2;
}

ATTRIBUTE_NODISCARD_WITH_MESSAGE("test returns true on success and false otherwise")
ATTRIBUTE_CONST
CONSTEXPR_IF_AT_LEAST_CXX_20 bool test_transpose_64x64() noexcept {
    // clang-format off
    CStyleMatrix64x64 a = {
        0b0000000000000000000000000000000000000000000000000000000000010101,
        0b0000000000000000000000000000000000000000000000000000000000001010,
        0b0000000000000000000000000000000000000000000000000000000000000101,
        0b0000000000000000000000000000000000000000000000000000000000000010,
        0b0000000000000000000000000000000000000000000000000000000000000001,
        0b1111111111111111111111111111111111111111111111111111111111111111,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b1111111111111111111111111111111111111111111111111111111111111111,
    };
    constexpr CStyleMatrix64x64 b1 = {
        0b1000000000000000000000000000000000000000000000000000000000110101,
        0b1000000000000000000000000000000000000000000000000000000000101010,
        0b1000000000000000000000000000000000000000000000000000000000100101,
        0b1000000000000000000000000000000000000000000000000000000000100010,
        0b1000000000000000000000000000000000000000000000000000000000100001,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
    };
    constexpr CStyleMatrix64x64 b2 = {
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b1000010000000000000000000000000000000000000000000000000000000001,
        0b0100010000000000000000000000000000000000000000000000000000000001,
        0b1010010000000000000000000000000000000000000000000000000000000001,
        0b0101010000000000000000000000000000000000000000000000000000000001,
        0b1010110000000000000000000000000000000000000000000000000000000001,
    };
    // clang-format on
    static_assert(sizeof(a) == sizeof(b1));
    static_assert(sizeof(a) == sizeof(b2));

    transpose64(a);
    const bool f1 = std::equal(&a[0], &a[64], &b1[0]);

    // return 'a' to initial state
    transpose64(a);

    transpose64<true>(a);
    const bool f2 = std::equal(&a[0], &a[64], &b2[0]);

    auto random_gen = [random_state = uint64_t{872189}]() mutable constexpr noexcept {
        constexpr uint64_t A = std::minstd_rand0::multiplier;
        constexpr uint64_t C = std::minstd_rand0::increment;
        constexpr uint64_t M = std::minstd_rand0::modulus;
        random_state         = (A * random_state + C) % M;
        return random_state;
    };

    if (!config::is_constant_evaluated()) {
        // This test has too many operations for the compile time check
        CStyleMatrix64x64 src{};
        static_assert(sizeof(a) == sizeof(src));
        for (std::size_t iter = 1U << 20U; iter > 0; iter--) {
            for (std::size_t i = 0; i < 32; i++) {
                const uint64_t w = random_gen();
                a[i * 2]         = static_cast<uint32_t>(w);
                a[i * 2 + 1]     = static_cast<uint32_t>(w >> 32U);
            }
            std::copy(&a[0], &a[64], &src[0]);
            transpose64(a);
            for (std::size_t i = 0; i < 64; i++) {
                for (std::size_t j = i + 1; j < 64; j++) {
                    const uint64_t aij = (src[i] & (1ULL << j)) >> j;
                    const uint64_t aji = (src[j] & (1ULL << i)) >> i;
                    src[i] &= ~(1ULL << j);
                    src[i] |= aji << j;
                    src[j] &= ~(1ULL << i);
                    src[j] |= aij << i;
                }
            }
            if (!std::equal(&a[0], &a[64], &src[0])) {
                return false;
            }
        }
    }

    return f1 && f2;
}

// clang-format off
// NOLINTEND(cppcoreguidelines-avoid-c-arrays, hicpp-avoid-c-arrays, modernize-avoid-c-arrays)
// clang-format on

template <std::size_t Size, class WordType>
void test_for_size() noexcept {
    test_tools::log_tests_started();

    using matrix_t = square_bitmatrix<Size, WordType>;

    const auto test_noexcept_invariants = []() noexcept {
        constexpr size_t i = 0;
        constexpr size_t j = 0;
        constexpr std::pair<size_t, size_t> ij{i, j};
        constexpr matrix_t const_matrix{};
        matrix_t mutable_matrix{};

        static_assert(!noexcept(const_matrix.get_checked(i, j)));
        static_assert(!noexcept(const_matrix.get_checked(ij)));
        static_assert(noexcept(const_matrix.get_unchecked(i, j)));
        static_assert(noexcept(const_matrix.get_unchecked(ij)));

        static_assert(!noexcept(mutable_matrix.get_checked(i, j)));
        static_assert(!noexcept(mutable_matrix.get_checked(ij)));
        static_assert(noexcept(mutable_matrix.get_unchecked(i, j)));
        static_assert(noexcept(mutable_matrix.get_unchecked(ij)));

        static_assert(!noexcept(mutable_matrix.set_checked(i, j)));
        static_assert(!noexcept(mutable_matrix.set_checked(ij)));
        static_assert(noexcept(mutable_matrix.set_unchecked(i, j)));
        static_assert(noexcept(mutable_matrix.set_unchecked(ij)));
    };
    test_noexcept_invariants();

    const auto test_identity_matrix = [](const matrix_t& n) noexcept {
        assert((n == matrix_t::identity()));
        assert(n.any());
        assert(!n.none());
        assert(n.size() == n.rows() && n.size() == n.columns());
        if (n.size() >= 2) {
            assert(!n.all());
        } else {
            assert(n.all());
        }
        {
            assert(n.count() == Size);
            n.for_each_set_bit([](auto i, auto j) noexcept { assert(i == j); });
            size_t counter = 0;
            n.for_each_set_bit([&counter](auto, auto) noexcept { counter++; });
            assert(counter == Size);
            for (size_t row_index = 0; row_index < Size; row_index++) {
                n.for_each_set_bit_in_row(row_index,
                                          [row_index](const size_t column_index) noexcept {
                                              assert(row_index == column_index);
                                          });
            }
        }
    };
    const auto test_zero_matrix = [](const matrix_t& n) noexcept {
        assert((n == matrix_t::allzeros()));
        assert(!n.any());
        assert(n.none());
        assert(!n.all());
        assert(n.count() == 0);
        assert(n.size() == n.rows() && n.size() == n.columns());
        n.for_each_set_bit([](auto, auto) noexcept { assert(false); });
    };
    const auto test_ones_matrix = [](const matrix_t& n) noexcept {
        assert((n == matrix_t::allones()));
        assert(n.any());
        assert(!n.none());
        assert(n.all());
        assert(n.count() == n.rows() * n.columns());
        assert(n.size() == n.rows() && n.size() == n.columns());
        std::uint32_t counter = 0;
        n.for_each_set_bit([&counter](auto, auto) noexcept { counter++; });
        assert(counter == n.rows() * n.columns());
        auto m = n;
        m *= m;
        if constexpr (m.size() % 2 == 0) {
            assert((m == matrix_t::allzeros()));
        } else {
            assert((m == matrix_t::allones()));
        }
    };

    auto identity = matrix_t::identity();
    test_identity_matrix(identity);
    identity *= identity;
    test_identity_matrix(identity);
    identity *= matrix_t::identity();
    test_identity_matrix(identity);
    identity = identity * identity;
    test_identity_matrix(identity);
    identity.transpose();
    identity.transpose();
    test_identity_matrix(identity);
    identity.reset();
    test_zero_matrix(identity);

    auto zero_matrix = matrix_t::allzeros();
    test_zero_matrix(zero_matrix);
    zero_matrix *= zero_matrix;
    test_zero_matrix(zero_matrix);
    zero_matrix *= matrix_t::allzeros();
    test_zero_matrix(zero_matrix);
    zero_matrix = zero_matrix * zero_matrix;
    test_zero_matrix(zero_matrix);
    zero_matrix.transpose();
    test_zero_matrix(zero_matrix);
    zero_matrix.reset();
    test_zero_matrix(zero_matrix);
    zero_matrix ^= matrix_t::identity();
    test_identity_matrix(zero_matrix);
    zero_matrix ^= matrix_t::identity();
    test_zero_matrix(zero_matrix);

    auto ones_matrix = matrix_t::allones();
    test_ones_matrix(ones_matrix);
    ones_matrix.transpose();
    test_ones_matrix(ones_matrix);
    ones_matrix *= matrix_t::identity();
    test_ones_matrix(ones_matrix);
    ones_matrix.reset();
    test_zero_matrix(ones_matrix);
}

template <class WordType>
void test_for_word_type() noexcept {
    test_for_size<1, WordType>();
    test_for_size<2, WordType>();
    test_for_size<7, WordType>();
    test_for_size<8, WordType>();
    test_for_size<9, WordType>();
    test_for_size<15, WordType>();
    test_for_size<16, WordType>();
    test_for_size<17, WordType>();
    test_for_size<31, WordType>();
    test_for_size<32, WordType>();
    test_for_size<33, WordType>();
    test_for_size<63, WordType>();
    test_for_size<64, WordType>();
    test_for_size<65, WordType>();
    test_for_size<127, WordType>();
    test_for_size<128, WordType>();
    test_for_size<129, WordType>();
    test_for_size<255, WordType>();
    test_for_size<256, WordType>();
    test_for_size<257, WordType>();
}

void test_transpose_algorithms() noexcept {
#if CONFIG_HAS_AT_LEAST_CXX_20
    static_assert(test_transpose_8x8());
    static_assert(test_transpose_32x32());
    static_assert(test_transpose_64x64());
#endif
    assert(test_transpose_8x8());
    assert(test_transpose_32x32());
    assert(test_transpose_64x64());
}

void test_bitmatrix_with_different_word_types() noexcept {
    test_for_word_type<std::uint8_t>();
    // std::bitset uses unsigned long which is std::uint32_t on Windows.
    if constexpr (sizeof(std::bitset<1>) == sizeof(std::bitset<32>)) {
        test_for_word_type<std::uint32_t>();
    }
    if constexpr (sizeof(std::bitset<1>) == sizeof(std::bitset<64>)) {
        test_for_word_type<std::uint64_t>();
    }
}

}  // namespace

// clang-format off
// NOLINTEND(cert-dcl03-c, misc-static-assert, hicpp-static-assert, cppcoreguidelines-avoid-magic-numbers)
// clang-format on

int main() {
    test_transpose_algorithms();
    test_bitmatrix_with_different_word_types();
}
