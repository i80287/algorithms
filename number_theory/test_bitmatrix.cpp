#include <cassert>
#include <iostream>
#include <random>

#include "bitmatrix.hpp"
#include "test_tools.hpp"

ATTRIBUTE_CONST
#if CONFIG_HAS_AT_LEAST_CXX_20
constexpr
#endif
    bool
    test_transpose_8x8() {
    // clang-format off
    uint8_t a[8] = {
        0b00011000,
        0b00011000,
        0b11111111,
        0b01101110,
        0b01100111,
        0b11111111,
        0b00011000,
        0b10011000,
    };
    constexpr uint8_t b1[8] = {
        0b00110100,
        0b00111100,
        0b00111100,
        0b11101111,
        0b11100111,
        0b00111100,
        0b00111100,
        0b10100100,
    };
    constexpr uint8_t b2[8] = {
        0b00100101,
        0b00111100,
        0b00111100,
        0b11100111,
        0b11110111,
        0b00111100,
        0b00111100,
        0b00101100,
    };
    // clang-format on
    static_assert(sizeof(a) == sizeof(b1));
    static_assert(sizeof(a) == sizeof(b2));

    transpose8(a, a);
    bool f1 = std::equal(&a[0], &a[8], &b1[0]);

    // return 'a' to initial state
    transpose8(a, a);

    transpose8<true>(a, a);
    bool f2 = std::equal(&a[0], &a[8], &b2[0]);

    return f1 && f2;
}

ATTRIBUTE_CONST
#if CONFIG_HAS_AT_LEAST_CXX_20
constexpr
#endif
    bool
    test_transpose_32x32() {
    // clang-format off
    uint32_t a[32] = {
        0b00011000000000000000000000000001U,
        0b00011000000000000000000000000010U,
        0b11111111000000000000000000001100U,
        0b01101110000000000000000000000000U,
        0b01100111000000000000000000000000U,
        0b11111111000000000000000000000000U,
        0b00011000000000000000000000000000U,
        0b00011000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
    };
    constexpr uint32_t b1[32] = {
        0b00000000000000000000000000000001U,
        0b00000000000000000000000000000010U,
        0b00000000000000000000000000000100U,
        0b00000000000000000000000000000100U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000110100U,
        0b00000000000000000000000000111100U,
        0b00000000000000000000000000111100U,
        0b00000000000000000000000011101111U,
        0b00000000000000000000000011100111U,
        0b00000000000000000000000000111100U,
        0b00000000000000000000000000111100U,
        0b00000000000000000000000000100100U,
    };
    constexpr uint32_t b2[32] = {
        0b00100100000000000000000000000000U,
        0b00111100000000000000000000000000U,
        0b00111100000000000000000000000000U,
        0b11100111000000000000000000000000U,
        0b11110111000000000000000000000000U,
        0b00111100000000000000000000000000U,
        0b00111100000000000000000000000000U,
        0b00101100000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00000000000000000000000000000000U,
        0b00100000000000000000000000000000U,
        0b00100000000000000000000000000000U,
        0b01000000000000000000000000000000U,
        0b10000000000000000000000000000000U,
    };
    // clang-format on
    static_assert(sizeof(a) == sizeof(b1));
    static_assert(sizeof(a) == sizeof(b2));

    transpose32(a);
    bool f1 = std::equal(&a[0], &a[32], &b1[0]);

    // return 'a' to initial state
    transpose32(a);

    transpose32<true>(a);
    bool f2 = std::equal(&a[0], &a[32], &b2[0]);

    return f1 && f2;
}

ATTRIBUTE_CONST
#if CONFIG_HAS_AT_LEAST_CXX_20
constexpr
#endif
    bool
    test_transpose_64x64() {
    // clang-format off
    uint64_t a[64] = {
        0b0000000000000000000000000000000000000000000000000000000000010101,
        0b0000000000000000000000000000000000000000000000000000000000001010,
        0b0000000000000000000000000000000000000000000000000000000000000101,
        0b0000000000000000000000000000000000000000000000000000000000000010,
        0b0000000000000000000000000000000000000000000000000000000000000001,
        0b1111111111111111111111111111111111111111111111111111111111111111,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b0000000000000000000000000000000000000000000000000000000000000000,
        0b1111111111111111111111111111111111111111111111111111111111111111,
    };
    constexpr uint64_t b1[64] = {
        0b1000000000000000000000000000000000000000000000000000000000110101,
        0b1000000000000000000000000000000000000000000000000000000000101010,
        0b1000000000000000000000000000000000000000000000000000000000100101,
        0b1000000000000000000000000000000000000000000000000000000000100010,
        0b1000000000000000000000000000000000000000000000000000000000100001,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
        0b1000000000000000000000000000000000000000000000000000000000100000,
    };
    constexpr uint64_t b2[64] = {
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b0000010000000000000000000000000000000000000000000000000000000001,
        0b1000010000000000000000000000000000000000000000000000000000000001,
        0b0100010000000000000000000000000000000000000000000000000000000001,
        0b1010010000000000000000000000000000000000000000000000000000000001,
        0b0101010000000000000000000000000000000000000000000000000000000001,
        0b1010110000000000000000000000000000000000000000000000000000000001,
    };
    // clang-format on
    static_assert(sizeof(a) == sizeof(b1));
    static_assert(sizeof(a) == sizeof(b2));

    transpose64(a);
    bool f1 = std::equal(&a[0], &a[64], &b1[0]);

    // return 'a' to initial state
    transpose64(a);

    transpose64<true>(a);
    bool f2 = std::equal(&a[0], &a[64], &b2[0]);

    auto random_gen = [random_state = uint64_t(872189)]() mutable constexpr noexcept {
        constexpr uint64_t A = std::minstd_rand0::multiplier;
        constexpr uint64_t C = std::minstd_rand0::increment;
        constexpr uint64_t M = std::minstd_rand0::modulus;
        random_state         = (A * random_state + C) % M;
        return random_state;
    };

    if (!config_is_constant_evaluated()) {
        // This test has too many operations for the compile time check
        uint64_t src[64] = {};
        static_assert(sizeof(a) == sizeof(src));
        for (std::size_t iter = 1u << 20; iter > 0; iter--) {
            for (std::size_t i = 0; i < 32; i++) {
                uint64_t w   = random_gen();
                a[i * 2]     = uint32_t(w);
                a[i * 2 + 1] = uint32_t(w >> 32);
            }
            std::copy(&a[0], &a[64], &src[0]);
            transpose64(a);
            for (std::size_t i = 0; i < 64; i++) {
                for (std::size_t j = i + 1; j < 64; j++) {
                    auto aij = (src[i] & (1ull << j)) >> j;
                    auto aji = (src[j] & (1ull << i)) >> i;
                    src[i] &= ~(1ull << j);
                    src[i] |= aji << j;
                    src[j] &= ~(1ull << i);
                    src[j] |= aij << i;
                }
            }
            if (!std::equal(&a[0], &a[64], &src[0])) {
                return false;
            }
        }
    }

    return f1 && f2;
}

template <std::size_t Size, class TWordType>
static void test_for_size() {
    using matrix_t = square_bitmatrix<Size, TWordType>;

    auto test_identity_matrix = [](const matrix_t& n) {
        assert((n == matrix_t::identity()));
        assert(n.any());
        assert(!n.none());
        assert(n.size() == n.rows() && n.size() == n.columns());
        if (n.size() >= 2) {
            assert(!n.all());
        } else {
            assert(n.all());
        }
        {
            assert(n.count() == Size);
            n.for_each_set_bit([](auto i, auto j) { assert(i == j); });
            auto counter = 0;
            n.for_each_set_bit([&counter](auto, auto) { counter++; });
            assert(counter == Size);
        }
    };
    auto test_zero_matrix = [](const matrix_t& n) {
        assert((n == matrix_t::allzeros()));
        assert(!n.any());
        assert(n.none());
        assert(!n.all());
        assert(n.count() == 0);
        assert(n.size() == n.rows() && n.size() == n.columns());
        n.for_each_set_bit([](auto, auto) { assert(false); });
    };
    auto test_ones_matrix = [](const matrix_t& n) {
        assert((n == matrix_t::allones()));
        assert(n.any());
        assert(!n.none());
        assert(n.all());
        assert(n.count() == n.rows() * n.columns());
        assert(n.size() == n.rows() && n.size() == n.columns());
        std::uint32_t counter = 0;
        n.for_each_set_bit([&counter](auto, auto) { counter++; });
        assert(counter == n.rows() * n.columns());
        auto m = n;
        m *= m;
        if constexpr (m.size() % 2 == 0) {
            assert((m == matrix_t::allzeros()));
        } else {
            assert((m == matrix_t::allones()));
        }
    };

    auto identity = matrix_t::identity();
    test_identity_matrix(identity);
    identity *= identity;
    test_identity_matrix(identity);
    identity *= matrix_t::identity();
    test_identity_matrix(identity);
    identity = identity * identity;
    test_identity_matrix(identity);
    identity.transpose();
    identity.transpose();
    test_identity_matrix(identity);
    identity.reset();
    test_zero_matrix(identity);

    auto zero_matrix = matrix_t::allzeros();
    test_zero_matrix(identity);
    zero_matrix *= zero_matrix;
    test_zero_matrix(identity);
    zero_matrix *= matrix_t::allzeros();
    test_zero_matrix(identity);
    // zero_matrix = zero_matrix * zero_matrix;
    // test_zero_matrix(identity);
    identity.transpose();
    test_zero_matrix(identity);
    identity.reset();
    test_zero_matrix(identity);

    auto ones_matrix = matrix_t::allones();
    test_ones_matrix(ones_matrix);
    ones_matrix.transpose();
    test_ones_matrix(ones_matrix);
    ones_matrix *= matrix_t::identity();
    test_ones_matrix(ones_matrix);
    ones_matrix.reset();
    test_zero_matrix(ones_matrix);
}

template <class TWordType>
static void test_for_word_type() {
    test_for_size<1, TWordType>();
    test_for_size<2, TWordType>();
    test_for_size<7, TWordType>();
    test_for_size<8, TWordType>();
    test_for_size<9, TWordType>();
    test_for_size<15, TWordType>();
    test_for_size<16, TWordType>();
    test_for_size<17, TWordType>();
    test_for_size<31, TWordType>();
    test_for_size<32, TWordType>();
    test_for_size<33, TWordType>();
    test_for_size<63, TWordType>();
    test_for_size<64, TWordType>();
    test_for_size<65, TWordType>();
    test_for_size<127, TWordType>();
    test_for_size<128, TWordType>();
    test_for_size<129, TWordType>();
    test_for_size<255, TWordType>();
    test_for_size<256, TWordType>();
    test_for_size<257, TWordType>();
}

int main() {
#if CONFIG_HAS_AT_LEAST_CXX_20
    static_assert(test_transpose_8x8());
    static_assert(test_transpose_32x32());
    static_assert(test_transpose_64x64());
#endif
    assert(test_transpose_8x8());
    assert(test_transpose_32x32());
    assert(test_transpose_64x64());

    test_for_word_type<std::uint8_t>();
    // std::bitset uses unsigned long which is std::uint32_t on Windows.
    if constexpr (sizeof(std::bitset<32 + 1>) == sizeof(std::bitset<32 + 32>)) {
        test_for_word_type<std::uint32_t>();
    }
    if constexpr (sizeof(std::bitset<64 + 1>) == sizeof(std::bitset<64 + 64>)) {
        test_for_word_type<std::uint64_t>();
    }
}
