#include <array>
#include <cassert>
#include <chrono>
#include <cinttypes>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <limits>
#include <memory>
#include <string>
#include <string_view>
#include <type_traits>
#include <vector>

#include "../misc/config_macros.hpp"
#include "../misc/test_tools.hpp"
#include "integers_128_bit.hpp"
#include "longint.hpp"
#include "math_functions.hpp"

// clang-format off
// NOLINTBEGIN(cert-dcl03-c, misc-static-assert, hicpp-static-assert, cppcoreguidelines-avoid-magic-numbers)
// clang-format on

namespace {

using std::int32_t;
using std::int64_t;
using std::size_t;
using std::uint32_t;
using std::uint64_t;

constexpr std::array<int64_t, 26> numbersI64 = {
    0,
    1,
    -1,
    2,
    -2,
    4,
    -4,
    8,
    -8,
    9,
    -9,
    10,
    -10,
    11,
    -11,
    2147483648LL,
    -2147483648LL,
    4294967295LL,
    -4294967295LL,
    4294967296LL,
    -4294967296LL,
    131241234423234LL,
    5984348957348LL,
    9223372036854775807LL,
    -9223372036854775807LL,
    -9223372036854775807LL - 1,
};

constexpr std::array<uint64_t, 13> numbersU64 = {
    0,
    1,
    2,
    4,
    8,
    9,
    10,
    11,
    2147483648,
    4294967295,
    4294967296,
    9223372036854775808ULL,
    18446744073709551615ULL,
};

constexpr std::array<uint128_t, 14> numbersU128 = {
    uint128_t{0},
    uint128_t{1},
    uint128_t{2},
    uint128_t{4},
    uint128_t{8},
    uint128_t{9999999999} * 10'000'000'000 + 9999999999,
    (uint128_t{42576258ULL} << 64U) | uint128_t{9439515947379090504ULL},
    (uint128_t{4581048384968843434ULL} << 64U) | (uint128_t{15881123738085757915ULL}),
    (uint128_t{15146611459005431080ULL} << 64U) | (uint128_t{11003818173265126250ULL}),
    (uint128_t{107408329755340997ULL} << 64U) | (uint128_t{10118848797326968254ULL}),
    (uint128_t{15406421307076602009ULL} << 64U) | (uint128_t{3266360438134194608ULL}),
    (uint128_t{13098489512494978084ULL} << 64U) | (uint128_t{13194323124312210617ULL}),
    (uint128_t{9593560117762545909ULL} << 64U) | (uint128_t{6883651453229059866ULL}),
    static_cast<uint128_t>(-1),
};

void AssertInvariants(const longint& n) noexcept {
    static_assert(noexcept(n.size()));
    static_assert(noexcept(n.usize()));
    static_assert(noexcept(n.capacity()));
    static_assert(noexcept(n.begin()));
    static_assert(noexcept(n.end()));
    static_assert(noexcept(n.cbegin()));
    static_assert(noexcept(n.cend()));
    static_assert(noexcept(n.rbegin()));
    static_assert(noexcept(n.rend()));
    static_assert(noexcept(*n.begin()));
    static_assert(noexcept(*n.end()));
    static_assert(noexcept(n.empty()));
    static_assert(noexcept(n.is_zero()));
    static_assert(noexcept(static_cast<bool>(n)));
    static_assert(noexcept(!n));
    assert(math_functions::uabs(n.size()) == n.usize());
    assert(n.usize() <= n.capacity());
    assert(n.capacity() <= longint::max_size());
    if (n.empty()) {
        assert(n.size() == 0);
        assert(n.begin() == n.end());
    } else {
        assert(n.size() != 0);
        assert(n.begin() < n.end());
        const auto last_digit = *(n.end() - 1);
        assert(last_digit > 0);
    }
}

void TestSemantic() {
    test_tools::log_tests_started();

    static_assert(std::is_default_constructible_v<longint>, "");
    static_assert(std::is_copy_constructible_v<longint>, "");
    static_assert(std::is_copy_assignable_v<longint>, "");
    static_assert(std::is_nothrow_move_constructible_v<longint>, "");
    static_assert(std::is_nothrow_move_assignable_v<longint>, "");
    static_assert(std::is_nothrow_destructible_v<longint>, "");
    static_assert(std::is_nothrow_swappable_v<longint>, "");

    static constexpr uint32_t k1 = 10;
    static constexpr uint32_t k2 = 100;

    longint n{k1};

    longint m = n;
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);

    m = k2;
    static_assert(k1 != k2);
    assert(n != m);

    m.swap(n);
    assert(n == k2);
    assert(m == k1);

    swap(n, m);
    assert(n == k1);
    assert(m == k2);

    n = std::move(m);
    assert(n == k2);

    m.assign_zero();
    assert(m == 0);
    assert(m.is_zero());

    n = m;
    assert(n == m);
    assert(n.is_zero());
}

void TestOperatorEqualsInt() {
    test_tools::log_tests_started();
    longint n;

    static constexpr int32_t K = 150'000;

    n = 0;
    assert(n.sign() == 0);
    assert(n.size() == 0);
    assert(n == 0);
    assert(n.is_zero());
    assert(!n);
    AssertInvariants(n);
    for (int32_t i = 1; i <= K; i++) {
        n = i;
        assert(n.sign() == 1);
        assert(n.size() == 1 && n[0] == static_cast<uint32_t>(i));
        assert(n == i);
        assert(n != -i);
        AssertInvariants(n);
    }
    for (int32_t i = -K; i < 0; i++) {
        n = i;
        assert(n.sign() == -1);
        assert(n.size() == -1 && n[0] == static_cast<uint32_t>(-i));
        assert(n == i);
        assert(n != -i);
        AssertInvariants(n);
    }

    n = 0U;
    assert(n.sign() == 0);
    assert(n.size() == 0);
    assert(n == 0U);
    assert(n.is_zero());
    assert(!n);
    AssertInvariants(n);
    for (uint32_t i = 1; i <= K; i++) {
        n = i;
        assert(n.sign() == 1);
        assert(n.size() == 1 && n[0] == i);
        assert(n == i);
        assert(n != -int64_t{i});
        AssertInvariants(n);
    }

    n = int64_t{0};
    assert(n.sign() == 0);
    assert(n.size() == 0);
    assert(n == int64_t{0});
    assert(n.is_zero());
    assert(!n);
    AssertInvariants(n);
    for (int64_t i = 1; i <= K; i++) {
        n = i;
        assert(n.sign() == 1);
        assert(n.size() == 1 && n[0] == static_cast<uint32_t>(i));
        assert(n == i);
        assert(n != -i);
        AssertInvariants(n);
    }
    for (int64_t i = -K; i < 0; i++) {
        n = i;
        assert(n.sign() == -1);
        assert(n.size() == -1 && n[0] == static_cast<uint32_t>(-i));
        assert(n == i);
        assert(n != -i);
        AssertInvariants(n);
    }

    n = uint64_t{0};
    assert(n.sign() == 0);
    assert(n.size() == 0);
    assert(n == uint64_t{0});
    assert(n.is_zero());
    assert(!n);
    AssertInvariants(n);
    for (uint64_t i = 1; i < K; i++) {
        n = i;
        assert(n.sign() == 1);
        assert(n.size() == 1 && n[0] == i);
        assert(n == i);
        assert(n != static_cast<int64_t>(-i));
        AssertInvariants(n);
    }

    n = int128_t{0};
    assert(n.sign() == 0);
    assert(n.size() == 0);
    assert(n == int128_t{0});
    assert(n.is_zero());
    assert(!n);
    AssertInvariants(n);
    for (int64_t i = 1; i <= K; i++) {
        n = int128_t{i};
        assert(n.sign() == 1);
        assert(n.size() == 1 && n[0] == static_cast<uint32_t>(i));
        assert(n == int128_t{i});
        assert(n != -int128_t{i});
        AssertInvariants(n);
    }
    for (int64_t i = -K; i < 0; i++) {
        n = int128_t{i};
        assert(n.sign() == -1);
        assert(n.size() == -1 && n[0] == static_cast<uint32_t>(-i));
        assert(n == int128_t{i});
        assert(n != -int128_t{i});
        AssertInvariants(n);
    }

    n = uint128_t{0};
    assert(n.sign() == 0);
    assert(n.size() == 0);
    assert(n.is_zero());
    assert(!n);
    AssertInvariants(n);
    n = static_cast<uint128_t>(-1);
    assert(n.sign() == 1);
    assert(n.size() == 4);
    assert(n[0] == std::numeric_limits<uint32_t>::max() &&
           n[1] == std::numeric_limits<uint32_t>::max() &&
           n[2] == std::numeric_limits<uint32_t>::max() &&
           n[3] == std::numeric_limits<uint32_t>::max());
    AssertInvariants(n);

    for (uint64_t i = std::numeric_limits<uint64_t>::max() - K; i != 0; i++) {
        n = i;
        assert(n == i);
        n = uint128_t{i};
        assert(n == uint128_t{i});
        assert(n != -int128_t{i});
        AssertInvariants(n);
    }
    for (uint128_t i = static_cast<uint128_t>(-1) - K; i != 0; i++) {
        n = i;
        assert(n == i);
        assert(n != (i - 1));
        assert(n != (i + 1));
        AssertInvariants(n);
    }
}

void TestLongIntMult() {
    test_tools::log_tests_started();

    longint n1;
    longint n2;
    static constexpr uint64_t K = 5000;
    for (uint32_t i = 0; i <= K; i++) {
        for (uint32_t j = 0; j <= K; j++) {
            n1 = i;
            n2 = j;
            n1 *= n2;
            assert(n1 == i * j);
            AssertInvariants(n1);
            AssertInvariants(n2);
        }
    }

    for (uint64_t i = std::numeric_limits<uint64_t>::max() - K; i != 0; i++) {
        for (uint64_t j = std::numeric_limits<uint64_t>::max() - K; j != 0; j++) {
            n1 = i;
            n2 = j;
            n1 *= n2;
            assert(n1 == uint128_t{i} * uint128_t{j});
            AssertInvariants(n1);
            AssertInvariants(n2);
        }
    }

    struct TestCase {
        std::string_view left_mult{};
        std::string_view right_mult{};
        std::string_view product{};
    };
    static constexpr std::array kTestCases = {
        TestCase{
            "0",
            "0",
            "0",
        },
        TestCase{
            "0",
            "1",
            "0",
        },
        TestCase{
            "1",
            "0",
            "0",
        },
        TestCase{
            "0",
            "99999999999999999999999999999999999999999999999999999999999",
            "0",
        },
        TestCase{
            "99999999999999999999999999999999999999999999999999999999999",
            "0",
            "0",
        },
        TestCase{
            "1",
            "1",
            "1",
        },
        TestCase{
            "2",
            "1",
            "2",
        },
        TestCase{
            "1",
            "2",
            "2",
        },
        TestCase{
            "10",
            "20",
            "200",
        },
        TestCase{
            "12",
            "20",
            "240",
        },
        TestCase{
            "1024",
            "4",
            "4096",
        },
        TestCase{
            "12000000",
            "20000000",
            "240000000000000",
        },
        TestCase{
            "13721838",
            "317826897",
            "4361169192676686",
        },
        TestCase{
            "317826897",
            "13721838",
            "4361169192676686",
        },
        TestCase{
            "131241234423234",
            "5984348957348",
            "785393344381744834046223432",
        },
        TestCase{
            "340282367000166625996085689103316680705",
            "340282367000166625996085689103316680705",
            "115792089291236088776703569810027986869841637790274196431140198001898"
            "919297025",
        },
        TestCase{
            "273467824687236487236847263874236482736428764827364813231889217390184"
            "829348917249234892378961402352793846723542349823849279432378472893534"
            "9239875",
            "234890218513205634872423783145093845309415709814503975130984759381491"
            "4534715981347589134057893417",
            "642349170971159888904111587665401864943296318873272674206402598998481"
            "144001829012658620088464132921787070037675404241160766315820847757326"
            "085007615660887268742042704088972688871700404868535028458255349812618"
            "7128453709828981195657834716402875",
        },
        TestCase{
            "952263744",
            "9359517973",
            "8912729627004270912",
        },
        TestCase{
            "4219788824",
            "2743656178",
            "11577649676822954672",
        },
        TestCase{
            "2968434375",
            "517784556",
            "1537009474874512500",
        },
        TestCase{
            "84505427146800725206214423388331447259",
            "279405665168189620898465228388855751530",
            "236112950822738450044078891891140511945155493452385217141226440086310"
            "03556270",
        },
        TestCase{
            "241624483789163450827236083147698994361",
            "176969948248112551859871363564234198810",
            "427602723916451661211499909053727503369996114756759726074868690213215"
            "42910410",
        },
        TestCase{
            "189745687871346578913675631984859831398756913846314756",
            "23423242342342342342342342345689457967408570698981759840534",
            "444445923042499901900288719235071035985372602038867414228977476967324"
            "0565480827228712761450490207639434131119704",
        },
        TestCase{
            "23423242342342342342342342345689457967408570698981759840534",
            "189745687871346578913675631984859831398756913846314756",
            "444445923042499901900288719235071035985372602038867414228977476967324"
            "0565480827228712761450490207639434131119704",
        },
        TestCase{
            "263784627842638746283742347238428746238753489753984753489753895734895"
            "374598347593874590834823942389472893472983472983472984372983742894",
            "217389254359307583476294856287563891627462895613761974651784651756317"
            "561375613856310601356801561875871568715681346134571638145631413008153"
            "301138138",
            "573439435581586836344503148729108267131512809685670894440858871665949"
            "350249919608663834189665543320561328456411904268336709732076203336012"
            "709472247344406733059180011504893572100921001789368036815755131341796"
            "530761123858780924440928033173601703530960115961336341530612366213698"
            "91372",
        },
        TestCase{
            "497901391203133639584365248205694454191787983065888808021086054694516"
            "231678400769672247210449029211500692922450556195262154964450750615790"
            "589514188335169335767186667337238748906460179043594327975307613550873"
            "497640298659014179164027572907511030105218252598212205594530882278634"
            "877454130119091726705601029352202171195390872242698817060048675435915"
            "135527964210732602071032081196558962307757791960427679399529069324160"
            "549893369013101650049983041135188532935882809944537521495309524288328"
            "855117560004063950897329061825463265670807769803264433240453165419466"
            "124032708997652022855881507054705048360737029012888066511549342858319"
            "594221414437025268041662318574212665165197120587703338083508692868300"
            "677764770579732322663775467094391395549962995658143805157903378864641"
            "845529422222679420854277324025081357759529782057143902526044318608364"
            "773982488660170606054513097933784945464089479906701766065102979875971"
            "016186695987772994526141888182685329927553791394052980374860153388855"
            "6248642308523858954129309895839621",
            "108970620860112407137081415322742626853869366153607749269340200211370"
            "607783690889706401071971517605562911982171828098546334623182361783101"
            "527622674806797503240534309482808265776920525225913147483110997329125"
            "774929345411974578604409416298333424465618343704848658619059126047806"
            "968312617008037576720611676699711149503491022606985517565868797501921"
            "068402587653953249565108588704327397129174524695783763087364999447101"
            "233545982819083696205282296476137023754198789925143561112064292009350"
            "446578133843184706267448822832804838688761964596529899405643175114579"
            "837421411209617498646939693870084669070186947256565085434101186597907"
            "574721562115573828577120603334862160941496987738531194216605182014973"
            "559629133888929125188010648321192064868491615965928704952858784948813"
            "028262472375484232230838139028017592044534551940157817797571827142402"
            "193452406502015912170734287622055641671015226994756461398538648113704"
            "080006243527381200070072950459571659161258052892532223431066903464363"
            "6549786097960658822655773576934232",
            "542566237265191827529937514862954000646132192075670117028672556256875"
            "922981088057291176984953735545161000556996022800239121508505284757162"
            "268909483205498527914555274916168104686152671316244053413629649078592"
            "844221574454571143934298344272998274912039073349090700964702105431117"
            "052463313257026624080682902654613968760291690022965464553805515048545"
            "665814919756077899170782027815231369213297957660369219056733043223216"
            "650840611758386426651922228988776810169486935905786827971524608998934"
            "425480935592871847645329482203292850871800388282012154597553095349607"
            "061204124457639261614130984224601794030397716760678442804462930109239"
            "835200526589104558673734410275262228604661026783817421504731331566088"
            "159708333768459589296158398589645874726780789841965979149435313871784"
            "574855631200841764582159920684861974889545204330460968586302517203122"
            "757973861795664515823524825857550948072156021944827265006595069604640"
            "738609954368159474130242374101753694907633771930949978927315952622963"
            "200910399588310149423264017858244366418817160565161767936461007176434"
            "269452654579036827321940037520503715766834671004963497569735239076366"
            "322219524988756271804939185010822228086674414859379562218488021336743"
            "306279704576159643873067598070257884809075861268963824687803796573476"
            "656878994600856192230007507779855209591502919396895345613654967245608"
            "523561870429177696792471853823824979863659724994067540824448641360311"
            "020227810345973361697859149797441211765701947995273129491616164699781"
            "392550089934232138435257056976549602983289316350764782395107969550665"
            "644683069258104940473930427699017753413415103826696248529241526525773"
            "801855865477090197744456373594926654289133012873441919699920026875851"
            "916411337332255415651235834231397577746492925103509724219067053721769"
            "683258816781174862025112986918398848628743047602431938875162380059549"
            "757320510979602398036873972216468125267715591928946645842024992422856"
            "453314591343472715775836081790421367120745661633730990368643807993416"
            "7085071256457656974379118052493980516605329326027531228264736806072",
        },
        TestCase{
            "108970620860112407137081415322742626853869366153607749269340200211370"
            "607783690889706401071971517605562911982171828098546334623182361783101"
            "527622674806797503240534309482808265776920525225913147483110997329125"
            "774929345411974578604409416298333424465618343704848658619059126047806"
            "968312617008037576720611676699711149503491022606985517565868797501921"
            "068402587653953249565108588704327397129174524695783763087364999447101"
            "233545982819083696205282296476137023754198789925143561112064292009350"
            "446578133843184706267448822832804838688761964596529899405643175114579"
            "837421411209617498646939693870084669070186947256565085434101186597907"
            "574721562115573828577120603334862160941496987738531194216605182014973"
            "559629133888929125188010648321192064868491615965928704952858784948813"
            "028262472375484232230838139028017592044534551940157817797571827142402"
            "193452406502015912170734287622055641671015226994756461398538648113704"
            "080006243527381200070072950459571659161258052892532223431066903464363"
            "6549786097960658822655773576934232",
            "497901391203133639584365248205694454191787983065888808021086054694516"
            "231678400769672247210449029211500692922450556195262154964450750615790"
            "589514188335169335767186667337238748906460179043594327975307613550873"
            "497640298659014179164027572907511030105218252598212205594530882278634"
            "877454130119091726705601029352202171195390872242698817060048675435915"
            "135527964210732602071032081196558962307757791960427679399529069324160"
            "549893369013101650049983041135188532935882809944537521495309524288328"
            "855117560004063950897329061825463265670807769803264433240453165419466"
            "124032708997652022855881507054705048360737029012888066511549342858319"
            "594221414437025268041662318574212665165197120587703338083508692868300"
            "677764770579732322663775467094391395549962995658143805157903378864641"
            "845529422222679420854277324025081357759529782057143902526044318608364"
            "773982488660170606054513097933784945464089479906701766065102979875971"
            "016186695987772994526141888182685329927553791394052980374860153388855"
            "6248642308523858954129309895839621",
            "542566237265191827529937514862954000646132192075670117028672556256875"
            "922981088057291176984953735545161000556996022800239121508505284757162"
            "268909483205498527914555274916168104686152671316244053413629649078592"
            "844221574454571143934298344272998274912039073349090700964702105431117"
            "052463313257026624080682902654613968760291690022965464553805515048545"
            "665814919756077899170782027815231369213297957660369219056733043223216"
            "650840611758386426651922228988776810169486935905786827971524608998934"
            "425480935592871847645329482203292850871800388282012154597553095349607"
            "061204124457639261614130984224601794030397716760678442804462930109239"
            "835200526589104558673734410275262228604661026783817421504731331566088"
            "159708333768459589296158398589645874726780789841965979149435313871784"
            "574855631200841764582159920684861974889545204330460968586302517203122"
            "757973861795664515823524825857550948072156021944827265006595069604640"
            "738609954368159474130242374101753694907633771930949978927315952622963"
            "200910399588310149423264017858244366418817160565161767936461007176434"
            "269452654579036827321940037520503715766834671004963497569735239076366"
            "322219524988756271804939185010822228086674414859379562218488021336743"
            "306279704576159643873067598070257884809075861268963824687803796573476"
            "656878994600856192230007507779855209591502919396895345613654967245608"
            "523561870429177696792471853823824979863659724994067540824448641360311"
            "020227810345973361697859149797441211765701947995273129491616164699781"
            "392550089934232138435257056976549602983289316350764782395107969550665"
            "644683069258104940473930427699017753413415103826696248529241526525773"
            "801855865477090197744456373594926654289133012873441919699920026875851"
            "916411337332255415651235834231397577746492925103509724219067053721769"
            "683258816781174862025112986918398848628743047602431938875162380059549"
            "757320510979602398036873972216468125267715591928946645842024992422856"
            "453314591343472715775836081790421367120745661633730990368643807993416"
            "7085071256457656974379118052493980516605329326027531228264736806072",
        },
        TestCase{
            "398745897362857463485376489753649875364854634756893127583461753169476"
            "487536194573741578236174269138178478167188712671340573451475168475768"
            "13468751364056130456875613458136745",
            "348",
            "138763572282274397292911018434270156626969412895398808399044690102977"
            "817662595711662069226188645660086110402181672009626519561113358629567"
            "31087125474691533398992713483431587260",
        },
        TestCase{
            "348",
            "398745897362857463485376489753649875364854634756893127583461753169476"
            "487536194573741578236174269138178478167188712671340573451475168475768"
            "13468751364056130456875613458136745",
            "138763572282274397292911018434270156626969412895398808399044690102977"
            "817662595711662069226188645660086110402181672009626519561113358629567"
            "31087125474691533398992713483431587260",
        },
        TestCase{
            "521064401567922879406069432539095585333589848390805645835218385101837"
            "2555735221",
            "521064401567922879406069432539095585333589848390805645835218385101837"
            "2555735221",
            "271508110581337591266374006213668384075074032863180060266512914739142"
            "456172622787686672201433223907591836068343627329838282819700778580870"
            "36385802059859918841",
        },
        TestCase{
            "398745897362857463485376489753649875364854634756893127583461753169476"
            "487536194573741578236174269138178478167188712671340573451475168475768"
            "13468751364056130456875613458136745",
            "398745897362857463485376489753649875364854634756893127583461753169476"
            "487536194573741578236174269138178478167188712671340573451475168475768"
            "13468751364056130456875613458136745",
            "158998290663710458652907928386102189731894441557379140893911130204468"
            "729629180012082532017682144658368840447283002718093698410970322236959"
            "329738423137118403063843808542333663086419299601252781649552905024490"
            "422756290924999941542817862891684525955199054347881182431401273481363"
            "138211857637015928078713366709245314733667696374248162928864711919502"
            "5",
        },
        TestCase{
            "538714288092043980610037307269667416713870555024102721656419679779374"
            "923813527446566333299023119588532960327655160416672952650552265438069"
            "480844921279178590685230852805810043617124500309990368055562957",
            "538714288092043980610037307269667416713870555024102721656419679779374"
            "923813527446566333299023119588532960327655160416672952650552265438069"
            "480844921279178590685230852805810043617124500309990368055562957",
            "290213084194517758966516201644973136574935912430101593678728719207376"
            "239283543794185421070570977723421111953765127658270193387362711172917"
            "254842491555209808089298233500256901159707774581220239792305894702400"
            "718422627848242457771440142125225540017207158668021195884313003164633"
            "568953242740947472813766242520888691791570207128296293932060193742259"
            "027655131589237232055417058854401516386978283594190583849",
        },
        TestCase{
            "378473591711125662205318978307400782427783753923984686802121246042271"
            "316236774444461081305720113769234627500055999892631802251943506510613"
            "041576973905140659553198302268762932232635013075121844024010844209617"
            "001387445367992616947475847556277530823124716511381308443893601036689"
            "835540126414069661052087138994082036710162383386369932806029019860996"
            "789535859361485418449897433469146302768382820057178659536255110169359"
            "845196380565725061526581227067549629866724246482931073170051376781704"
            "197212768365253140559066042002101297055200613269143572019112557085563"
            "899878475510810554198342040963733144408262697470764570314944593526613"
            "934419263025337497357042571717671759023883586867451377168248733405883"
            "910296788303702062215452776471512256941837484725160214833729957202282"
            "648704994064553439348115504885342193852929906418451561210887575546337"
            "507615915632010857173564415901485308965735447198738488397867151647504"
            "526550040119974630239332996345427278593883623686974957277376278631354"
            "869639366838460468748101319039408427701123993442888448154403121426916"
            "704627733981704445112370876108453961872801955347846801218254087739489"
            "562170030806198132295724995482071830436648020515150300468035898691623"
            "269527628850137584131992179304108104221244082970339981314645",
            "242422360745395402404187893934203477400974449065647049988927198970319"
            "805753149705988973274875934705741319528222056518230978113788601185987"
            "597650863481917975147889480918426062465619374716968961931781307592900"
            "017970779362645595784950197534818861618814548119308868190069641017565"
            "582001182178863908348366042579709934563168161190371007834351658980901"
            "439537387725151710448936716057525234422021079168107409249681886185803"
            "656798184787755755302137461956528885902748067318538923549260818296551"
            "459793281096136811002727591059360446183594804912759682504651810130132"
            "241402424826964162913576719514934406842887250631366029807679608779995"
            "452685983217009380013356826166862603999974178446346927185519163124450"
            "042997576507464420018043214571816883931340327689828911413087854407416"
            "013902322113202969761256247555360669534677298033285373411229119624362"
            "114218631744679287995208711756999916330336680306667802886976862157913"
            "540009816489722867943929152313666052647540305002671654304297771170195"
            "703695712037696137032492879795700752067767022685233264574030743197818"
            "202098648173117308846148560570005975871944017411174794281674815109904"
            "233256841885601132453369966630233504941985437823039274173244307950067"
            "942092770927309358035074043249749436812689885822328999166497",
            "917504615823999964812490560695523410616319773621667959556544457902642"
            "228597203892116248150792838436259758633998890742122162662971349908155"
            "647613305941569852250475309540703819614371482131956000579690150103867"
            "335478224759580801158401367416866923388593255048676462217239894005505"
            "009293173974162215718916257677833210773428771087200121260806792118749"
            "401056565747653762978906896044361139468454441915586739520671907037366"
            "061178923181675896266118089995923451280607130137235218424615683169274"
            "638629109230340861539513364511680765354775168309144392850930437629909"
            "540394133815885217123604460615938103773946573454161215645170434248607"
            "885475252350857923430189977279480650126059654087213201630519852181484"
            "420704813284176064997930060799123094778253779356411014104775011619320"
            "890276285350085521042226184089357673933350600306949457583787046722645"
            "223193834579973303690497023431881676046233666783761209898616176106306"
            "729305364655669808769480217965819163342135473082505226302410863190468"
            "064569777465122355280724885358743713689472686982090153578230854097957"
            "195880970282340427948796059589784641830728955991808111545904442719713"
            "968653042471220082243271286370673789701162155117007120303537124233193"
            "275125118972895865679939043604689308535057054691688159958979192970492"
            "683643642024695575369794834267321472216711091276966830924761404911268"
            "187556249989351119873947551162147337246713550069804684687953776739927"
            "160721106545510088122128738416855312105051199067393501114750489112707"
            "303490618722690784630628219351880531189176857749421515617647625613905"
            "992645094759299281495020261468508383302524672961699120310427850850043"
            "608462954117991594441041525615782059524897217309809917382422228775783"
            "745334965416197148513545804017423917503503734483939356285877889547773"
            "524825669114358439184329239325471360281330935188244170013589217201763"
            "068697763253011631858147598565758360894999458452467192507663619987261"
            "612014164670771197354051123684835992187270895966932982720732420678204"
            "203847143455375866973089936570011460388228067165031434155375042497717"
            "403868873136480476131279697289876771903281296615905598206690477049313"
            "392033483312376581841307192363538822368201682123915484751895940728372"
            "363453862818847008212381931201750683359496089644866900948890514635439"
            "499038897053670375385502389269309919840640299039214251339389215673639"
            "932403778057364683711289609946099478058029490734553609251896107587556"
            "209723199428747459201558083692574616874349732490648481890083699349034"
            "17392669574477053593427918093472288422759299448565",
        },
    };
    for (const TestCase& test_case : kTestCases) {
        n1.set_string(test_case.left_mult);
        n2.set_string(test_case.right_mult);
        n1 *= n2;
        n2.set_string(test_case.product);
        assert(n1 == n2);
        AssertInvariants(n1);
        AssertInvariants(n2);
    }

    namespace chrono = std::chrono;

    static constexpr size_t k = static_cast<size_t>(1e6);
    n1.set_string(std::string(k, '9'));
    {
        auto start = chrono::high_resolution_clock::now();
        n1 *= n1;
        auto end = chrono::high_resolution_clock::now();
        std::printf("Multiplied %zu digit numbers in %" PRIu64 " microseconds\n", k,
                    static_cast<uint64_t>(
                        chrono::duration_cast<chrono::microseconds>(end - start).count()));
    }
    std::string ans(2 * k, '\0');
    std::char_traits<char>::assign(ans.data(), k - 1, '9');
    ans[k - 1] = '8';
    std::char_traits<char>::assign(std::addressof(ans[k]), k - 1, '0');
    ans[2 * k - 1] = '1';
    n2.set_string(ans);
    assert(n1 == n2 && "Long test failed");
    AssertInvariants(n1);
    AssertInvariants(n2);
}

void TestLongIntSquare() {
    test_tools::log_tests_started();

    longint n;
    n.reserve(4);
    static constexpr uint64_t K = 5000;
    for (uint32_t i = 0; i <= K; i++) {
        n = i;
        n.square_inplace();
        if (n != i * i) {
            std::cerr << "i = " << i << "\nn = " << n << '\n';
        }
        assert(n == i * i);
        AssertInvariants(n);
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - K; i != 0; i++) {
        n = i;
        n.square_inplace();
        assert(n == uint64_t{i} * i);
        AssertInvariants(n);
    }

    for (uint64_t i = std::numeric_limits<uint64_t>::max() - K; i != 0; i++) {
        n = i;
        n.square_inplace();
        assert(n == uint128_t{i} * i);
        AssertInvariants(n);
    }

    for (uint32_t p = 32; p <= 96; p += 32) {
        n = uint128_t{1} << p;
        n.square_inplace();
        const uint32_t size = (p + p) / longint::kNumsBits + 1;
        assert(n.size() == static_cast<typename longint::ssize_type>(size));
        for (size_t i = 0; i < size - 1; i++) {
            assert(n[i] == 0);
        }
        assert(n[size - 1] == 1);
        AssertInvariants(n);
    }

    n.set_string(
        "5210644015679228794060694325390955853335898483908056458352183851018372"
        "555735221");
    n.square_inplace();
    auto m = longint::from_string(
        "2715081105813375912663740062136683840750740328631800602665129147391424"
        "5617262278768667220143322390759183606834362732983828281970077858087036"
        "385802059859918841");
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);

    n.set_string(
        "3987458973628574634853764897536498753648546347568931275834617531694764"
        "8753619457374157823617426913817847816718871267134057345147516847576813"
        "468751364056130456875613458136745");
    n.square_inplace();
    m.set_string(
        "1589982906637104586529079283861021897318944415573791408939111302044687"
        "2962918001208253201768214465836884044728300271809369841097032223695932"
        "9738423137118403063843808542333663086419299601252781649552905024490422"
        "7562909249999415428178628916845259551990543478811824314012734813631382"
        "118576370159280787133667092453147336676963742481629288647119195025");
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);

    n.set_string(
        "5387142880920439806100373072696674167138705550241027216564196797793749"
        "2381352744656633329902311958853296032765516041667295265055226543806948"
        "0844921279178590685230852805810043617124500309990368055562957");
    n.square_inplace();
    m.set_string(
        "2902130841945177589665162016449731365749359124301015936787287192073762"
        "3928354379418542107057097772342111195376512765827019338736271117291725"
        "4842491555209808089298233500256901159707774581220239792305894702400718"
        "4226278482424577714401421252255400172071586680211958843130031646335689"
        "5324274094747281376624252088869179157020712829629393206019374225902765"
        "5131589237232055417058854401516386978283594190583849");
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);

    static constexpr size_t k = 572;
    std::string long_ten_pow(k + 1, '0');
    long_ten_pow[0] = '1';
    n.set_string(long_ten_pow);
    n.square_inplace();

    std::string long_ten_pow_square(2 * k + 1, '0');
    long_ten_pow_square[0] = '1';
    m.set_string(long_ten_pow_square);
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);
}

void TestUIntMult() {
    test_tools::log_tests_started();

    longint n;
    static constexpr uint64_t K = 5000;
    for (uint64_t i = 0; i <= K; i++) {
        for (uint32_t j = 0; j <= K; j++) {
            n = i;
            n *= j;
            assert(n == i * j);
            AssertInvariants(n);
        }
    }

    static constexpr uint128_t kStartPos1 = static_cast<uint128_t>(-1) / K;
    for (uint128_t i = kStartPos1 - K; i != kStartPos1; i++) {
        for (uint32_t j = 0; j < K; j++) {
            n = i;
            n *= j;
            assert(n == i * j);
            AssertInvariants(n);
        }
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - K; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n *= j;
            assert(n == uint64_t{i} * uint64_t{j});
            AssertInvariants(n);
        }
    }

    for (uint64_t i = std::numeric_limits<uint64_t>::max() - K; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n *= j;
            assert(n == uint128_t{i} * j);
            AssertInvariants(n);
        }
    }
}

void TestUIntAddAndSub() {
    test_tools::log_tests_started();

    longint n(longint::Reserve(4));
    static constexpr uint32_t K = 4000;
    n -= std::numeric_limits<uint32_t>::max();
    assert(n == -int64_t{std::numeric_limits<uint32_t>::max()});
    for (uint32_t i = 0; i <= K; i++) {
        for (uint32_t j = 0; j <= K; j++) {
            n = i;
            n += j;
            assert(n == i + j);
            AssertInvariants(n);
            n = i;
            n -= j;
            if (unlikely(i == j)) {
                assert(!n);
                assert(n.is_zero());
            }
            assert(n == int64_t{i} - int64_t{j});
            AssertInvariants(n);
        }
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - K; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == uint64_t{i} + uint64_t{j});
            AssertInvariants(n);
            n = i;
            n -= j;
            if (unlikely(i == j)) {
                assert(!n);
                assert(n.is_zero());
            }
            assert(n == int64_t{i} - int64_t{j});
            AssertInvariants(n);
        }
    }

    for (uint64_t i = std::numeric_limits<uint64_t>::max() - K; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == uint128_t{i} + uint128_t{j});
            AssertInvariants(n);
        }
    }

    const uint64_t kStartPos1 = std::numeric_limits<uint64_t>::max();
    for (uint128_t i = kStartPos1; i != uint128_t{kStartPos1} + 2 * uint128_t{K}; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == i + j);
            AssertInvariants(n);
        }
    }

    const uint128_t kStartPos2 = static_cast<uint128_t>(-1) / 2;
    for (uint128_t i = kStartPos2 - 2 * uint128_t{K}; i != kStartPos2; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == i + j);
            AssertInvariants(n);
        }
    }

    const int32_t kStartPos3 = std::numeric_limits<int32_t>::min();
    for (int32_t i = kStartPos3; i != static_cast<int32_t>(K) + kStartPos3; i++) {
        for (uint32_t j = 0; j <= K; j++) {
            n = i;
            n += j;
            assert(n == i + static_cast<int32_t>(j));
            AssertInvariants(n);
        }
    }

    for (int32_t i = kStartPos3; i != static_cast<int32_t>(K) + kStartPos3; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == i + int64_t{j});
            AssertInvariants(n);
        }
    }

    const int64_t kStartPos4 = -static_cast<int64_t>(1ULL << 62U);
    for (int64_t i = kStartPos4; i != int64_t{K} + kStartPos4; i++) {
        for (uint32_t j = 0; j <= K; j++) {
            n = i;
            n += j;
            assert(n == i + static_cast<int32_t>(j));
            AssertInvariants(n);
        }
    }

    for (int64_t i = kStartPos4; i != int64_t{K} + kStartPos4; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == i + int64_t{j});
            AssertInvariants(n);
        }
    }

    const int64_t kStartPos5 = std::numeric_limits<int64_t>::min();
    for (int64_t i = kStartPos5; i != int64_t{K} + kStartPos5; i++) {
        for (uint32_t j = 0; j <= K; j++) {
            n = i;
            n += j;
            assert(n == i + static_cast<int32_t>(j));
            AssertInvariants(n);
        }
    }

    for (int64_t i = kStartPos5; i != int64_t{K} + kStartPos5; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == i + int64_t{j});
            AssertInvariants(n);
        }
    }
}

void TestInt32Div() {
    test_tools::log_tests_started();

    longint n(longint::Reserve(4));
    static constexpr uint32_t K = 5000;

    for (uint32_t i = 0; i <= K; i++) {
        for (uint32_t j = 1; j <= K; j++) {
            n = i;
            n /= j;
            assert(n == i / j);
            AssertInvariants(n);
        }

        n = i;
        n /= uint32_t{1} << 0U;
        assert(n == i >> 0U);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 1U;
        assert(n == i >> 1U);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 2U;
        assert(n == i >> 2U);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 15U;
        assert(n == i >> 15U);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 31U;
        assert(n == i >> 31U);
    }
    for (uint32_t i = std::numeric_limits<uint32_t>::max() - K; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n /= j;
            assert(n == i / j);
            AssertInvariants(n);
        }

        n = i;
        n /= uint32_t{1} << 0U;
        assert(n == i >> 0U);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 1U;
        assert(n == i >> 1U);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 2U;
        assert(n == i >> 2U);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 15U;
        assert(n == i >> 15U);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 31U;
        assert(n == i >> 31U);
    }
}

void TestLongIntAddAndSub() {
    test_tools::log_tests_started();
    longint n(longint::Reserve{4});
    longint m(longint::Reserve{4});
    static constexpr uint32_t K = 5000;
    for (uint32_t i = 0; i <= K; i++) {
        for (uint32_t j = 0; j <= K; j++) {
            n = i;
            m = j;
            n += m;
            assert(n == i + j);
            AssertInvariants(n);
            n = i;
            n -= m;
            assert(n == int64_t{i} - int64_t{j});
            AssertInvariants(n);
        }
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - K; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            m = j;
            n += m;
            assert(n == i + uint64_t{j});
            AssertInvariants(n);
            n = i;
            n -= m;
            assert(n == int64_t{i} - int64_t{j});
            AssertInvariants(n);
        }
    }

    const auto kStartPos1 =
        std::numeric_limits<uint64_t>::max() - std::numeric_limits<uint32_t>::max();
    for (uint64_t i = kStartPos1 - K; i != kStartPos1; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            m = j;
            n += m;
            assert(n == i + j);
            AssertInvariants(n);
            n = i;
            n -= m;
            assert(n == i - j);
            AssertInvariants(n);
        }
    }

    const auto kStartPos2 = std::numeric_limits<uint64_t>::max();
    for (uint128_t i = kStartPos2; i != uint128_t{kStartPos2} + 2 * uint128_t{K}; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            m = j;
            n += m;
            assert(n == i + j);
            AssertInvariants(n);
            n = i;
            n -= m;
            assert(n == i - j);
            AssertInvariants(n);
        }
    }

    const uint128_t kStartPos3 = static_cast<uint128_t>(-1) / 2;
    for (uint128_t i = kStartPos3 - 2 * uint128_t{K}; i < kStartPos3; i++) {
        for (uint128_t j = kStartPos3 - 2 * uint128_t{K}; j < kStartPos3; j++) {
            n = i;
            m = j;
            n += m;
            assert(n == i + j);
            AssertInvariants(n);
            n = i;
            n -= m;
            assert(n == static_cast<int64_t>(i - j));
            AssertInvariants(n);
        }
    }
}

void AssertAllNumsSet(const longint& n, const size_t expected_set_nums_count) noexcept {
    assert(expected_set_nums_count < longint::max_size());
    assert(n.size() == static_cast<longint::ssize_type>(expected_set_nums_count));
    for (size_t i = 0; i < expected_set_nums_count; i++) {
        assert(n[i] == std::numeric_limits<longint::digit_t>::max());
    }
    AssertInvariants(n);
}

void TestSetString() {
    test_tools::log_tests_started();

    longint n;
    for (const int64_t number : numbersI64) {
        n.set_string(std::to_string(number));
        assert(n == number);
        AssertInvariants(n);
    }
    for (const uint64_t number : numbersU64) {
        n.set_string(std::to_string(number));
        assert(n == number);
        AssertInvariants(n);
    }
    for (const uint128_t number : numbersU128) {
        n.set_string(to_string(number));
        assert(n == number);
        AssertInvariants(n);
    }

    uint128_t c = 0;
    std::string s;
    s.reserve(39);
    for (size_t i = 0; i < 39; i++) {
        n.set_string(s);
        assert(n == c);
        s.push_back('9');
        c = c * 10 + 9;
    }

    // 2^256 - 1
    n.set_string("115792089237316195423570985008687907853269984665640564039457584007913129639935");
    AssertAllNumsSet(n, 256 / longint::kNumsBits);

    // 2^512 - 1
    n.set_string(
        "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801"
        "874298166903427690031858186486050853753882811946569946433649006084095");
    AssertAllNumsSet(n, 512 / longint::kNumsBits);

    // 2^1024 - 1
    n.set_string(
        "179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477"
        "322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302"
        "219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239"
        "947245938479716304835356329624224137215");
    AssertAllNumsSet(n, 1024 / longint::kNumsBits);
}

void TestToString() {
    test_tools::log_tests_started();
    std::string buffer;

    longint n;
    for (const int64_t number : numbersI64) {
        n = number;
        n.to_string(buffer);
        assert(buffer == std::to_string(number));
        AssertInvariants(n);
    }
    for (const uint64_t number : numbersU64) {
        n = number;
        n.to_string(buffer);
        assert(buffer == std::to_string(number));
        AssertInvariants(n);
    }
    for (const uint128_t number : numbersU128) {
        n = number;
        n.to_string(buffer);
        assert(buffer == to_string(number));
        AssertInvariants(n);
    }

    uint128_t c = 0;
    std::string s;
    s.reserve(39);
    buffer.reserve(39);
    n = c;
    n.to_string(buffer);
    assert(buffer.size() == 1 && buffer[0] == '0');
    for (size_t i = 0; i < 38; i++) {
        s.push_back('9');
        c = c * 10 + 9;
        n = c;
        assert(n == c);
        n.to_string(buffer);
        assert(buffer == s);
        AssertInvariants(n);
    }

    static constexpr size_t k = static_cast<size_t>(1e6);
    static constexpr size_t kSquareDigits = 2 * k;
    n.set_string(std::string(k, '9'));
    n.square_inplace();
    AssertInvariants(n);

    std::string ans(kSquareDigits, '\0');
    std::char_traits<char>::assign(ans.data(), k - 1, '9');
    ans[k - 1] = '8';
    std::char_traits<char>::assign(std::addressof(ans[k]), k - 1, '0');
    ans[kSquareDigits - 1] = '1';

    buffer.reserve(kSquareDigits + 1);
    n.to_string(buffer);
    assert(buffer == ans && "Long int set to_string test failed");

    n.flip_sign();
    n.to_string(buffer);
    assert(buffer[0] == '-');
    const std::string_view buffer_without_sign(&buffer[1], kSquareDigits);
    assert(buffer_without_sign == ans && "Long int set to_string test failed");
    AssertInvariants(n);
}

void TestBitShifts() {
    test_tools::log_tests_started();
    static constexpr uint32_t k = 5000;
    longint n;
    n.reserve(4);
    for (uint32_t i = 0; i <= k; i++) {
        for (uint32_t shift = 0; shift <= 31; shift++) {
            n = i;
            n >>= shift;
            assert(n == (i >> shift));
            AssertInvariants(n);
        }
        for (uint32_t j = 0; j <= 16; j++) {
            n = i;
            n >>= 32 + j;
            assert(n == 0);
            AssertInvariants(n);
        }
    }

    for (uint128_t i = static_cast<uint128_t>(-1) - k; i != 0; i++) {
        for (uint32_t shift = 0; shift <= 127; shift++) {
            n = i;
            n >>= shift;
            assert(n == (i >> shift));
            AssertInvariants(n);
        }
        for (uint32_t j = 0; j <= 16; j++) {
            n = i;
            n >>= 128 + j;
            assert(n == 0);
            AssertInvariants(n);
        }
    }

    // 1 << 255
    n.set_string("57896044618658097711785492504343953926634992332820282019728792003956564819968");
    longint m;
    m.reserve(n.usize());
    AssertInvariants(n);
    for (uint32_t shift = 0; shift <= 127; shift++) {
        m = n;
        m >>= (255 - shift);
        assert(m == uint128_t{1} << shift);
        AssertInvariants(m);
    }

    for (uint32_t r = 0; r <= k; r++) {
        n = 0;
        assert(n.is_zero());
        assert(n.sign() == 0);
        assert(n.size() == 0);
        AssertInvariants(n);
        n <<= r;
        assert(n == 0);
        assert(n.is_zero());
        assert(n.sign() == 0);
        assert(n.size() == 0);
        AssertInvariants(n);
    }
    for (uint32_t i = 1; i < k; i++) {
        const auto max_k = math_functions::log2_floor(static_cast<uint128_t>(-1) / i);
        for (uint32_t r = 0; r <= max_k; r++) {
            n = i;
            assert(n == i);
            n <<= r;
            assert(n == uint128_t{i} << r);
            assert(n.size() > 0);
            AssertInvariants(n);
        }
    }

    n = 1;
    n <<= 255;
    m.set_string("57896044618658097711785492504343953926634992332820282019728792003956564819968");
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);
    n = 1U;
    n <<= 4000;
    m.set_string(
        "131820409343094310010388979423659136318401916109327276909280345024175692811283445510797521"
        "231721220331409407564807168230384468176942405812817310624525121840385446744443868889563289"
        "706427719939300365865529242495144888321833894158323756200092849226089461110385787540779132"
        "654409185831255860504316472846036364908238500078268116724689002106891044880894853471921527"
        "088201197650061259448583977618746693012787452335047965869945140544352170538037327032402834"
        "008159261693483647994727160945768940072431686625688866030658324868306061250176433564697324"
        "072528745672177336948242366753233417556818392219546938204560720202538843712268268448586361"
        "942128751395665874453900680147479758139717481147704392488266886671292379541285558418744606"
        "657296304926586001793382725791100208812287673612006034789731201688939975743537276539989692"
        "230927982557016660679726989062369216287647728379155260864643891615705346169567037448405029"
        "752790940875872989684235165316260908983893514490200568512210790489667188789433092320719785"
        "756398772086212370409401269127676106581410793787580434036114254547441805771508552049371634"
        "609025127325512605396392214570059772472666763440181556475095153967113514875460624794445927"
        "79055555421362722504575706910949376");
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);
    n = 1U;
    n <<= 8000;
    m.set_string(
        "173766203193809456599982445949435627061939786100117250547173286503262376022458008465094333"
        "630120854338003194362163007597987225472483598640843335685441710193966274131338557192586399"
        "006789292714554767500194796127964596906605976605873665859580600161998556511368530960400907"
        "199253450604168622770350228527124626728538626805418833470107651091641919900725415994689920"
        "112219170907023561354484047025713734651608777544579846111001059482132180956689444108315785"
        "401642188044178788629853592228467331730519810763559577944882016286493908631503101121166109"
        "571682295769470379514531105239965209245314082665518579335511291525230373316486697786532335"
        "206274149240813489201828773854353041855598709390675430960381072270432383913542702130202430"
        "186637321862331068861776780211082856984506050024895394320139435868484643843368002496089956"
        "046419964019877586845530207748994394501505588146979082629871366088121763790555364513243984"
        "244004147636040219136443410377798011608722717131323621700159335786445601947601694025107888"
        "293017058178562647175461026384343438874861406516767158373279032321096262126551620255666605"
        "185789463207944391905756886829667520553014724372245300878786091700563444079107099009003380"
        "230356461989260377273986023281444076082783406824471703499844642915587790146384758051663547"
        "775336021829171033411043796977042190519657861762804226147480755555085278062866268677842432"
        "851421790544407006581148631979148571299417963950579210719961422405768071335213324842709316"
        "205032078384168750091017964584060285240107161561019930505687950233196051962261970932008838"
        "279760834318101044311710769457048672103958655016388894770892065267451228938951370237422841"
        "366052736174160431593023473217066764172949768821843606479073866252864377064398085101223216"
        "558344281956767163876579889759124956035672317578122141070933058555310274598884089982879647"
        "974020264495921703064439532898207943134374576254840272047075633856749514044298135927611328"
        "433323640657533550512376900773273703275329924651465759145114579174356770593439987135755889"
        "403613364529029604049868233807295134382284730745937309910703657676103447124097631074153287"
        "120040247837143656624045055614076111832245239612708339272798262887437416818440064925049838"
        "443370805645609424314780108030016683461562597569371539974003402697903023830108053034645133"
        "078208043917492087248958344081026378788915528519967248989338592027124423914083391771884524"
        "464968645052058218151010508471258285907685355807229880747677634789376");
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);

    auto test_compile_time_bit_shifts = [&n, &m](uint64_t i) {
        n = i;
        m = i;
        n /= uint32_t{1} << 0U;
        m >>= 0;
        assert(n == m);
        assert(!(n != m));
        assert(n == (i >> 0U));
        assert(m == (i >> 0U));
        AssertInvariants(n);
        AssertInvariants(m);

        n = i;
        m = i;
        n /= uint32_t{1} << 1U;
        m >>= 1;
        assert(n == m);
        assert(!(n != m));
        assert(n == (i >> 1U));
        assert(m == (i >> 1U));
        AssertInvariants(n);
        AssertInvariants(m);

        n = i;
        m = i;
        n /= uint32_t{1} << 2U;
        m >>= 2;
        assert(n == m);
        assert(!(n != m));
        assert(n == (i >> 2U));
        assert(m == (i >> 2U));
        AssertInvariants(n);
        AssertInvariants(m);

        n = i;
        m = i;
        n /= uint32_t{1} << 15U;
        m >>= 15;
        assert(n == m);
        assert(!(n != m));
        assert(n == (i >> 15U));
        assert(m == (i >> 15U));
        AssertInvariants(n);
        AssertInvariants(m);

        n = i;
        m = i;
        n /= uint32_t{1} << 31U;
        m >>= 31U;
        assert(n == m);
        assert(!(n != m));
        assert(n == (i >> 31U));
        assert(m == (i >> 31U));
        AssertInvariants(n);
        AssertInvariants(m);
    };
    for (uint64_t i = 0; i < k; i++) {
        test_compile_time_bit_shifts(i);
    }
    for (uint64_t i = std::numeric_limits<uint32_t>::max() - k; static_cast<uint32_t>(i) != 0;
         i++) {
        test_compile_time_bit_shifts(i);
    }
    for (uint64_t i = std::numeric_limits<uint64_t>::max() - k; i != 0; i++) {
        test_compile_time_bit_shifts(i);
    }
}

void TestDecimal() {
    test_tools::log_tests_started();
    longint::Decimal d1(0U);
    longint::Decimal d2(0U);
    static constexpr uint32_t kC = 2500;

    for (uint32_t i = 0; i <= kC; i++) {
        for (uint32_t j = 0; j <= kC; j++) {
            d1 = i;
            d2 = j;
            d1 += d2;
            assert(d1 == i + j);
        }
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - kC; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - kC; j != 0; j++) {
            d1 = i;
            d2 = j;
            d1 += d2;
            assert(d1 == uint64_t{i} + j);
        }
    }

    {
        d1 = static_cast<uint64_t>(1e18);
        static constexpr size_t k = 29;
        for (size_t i = 0; i < k; i++) {
            d1 += d1;
        }

        assert(d1.digits_.size() == 3 && d1.digits_[0] == 0 && d1.digits_[1] == 0 &&
               d1.digits_[2] == (1U << k));

        d1 += d1;
        assert(d1.digits_.size() == 4 && d1.digits_[0] == 0 && d1.digits_[1] == 0 &&
               d1.digits_[2] == (1U << (k + 1)) % longint::kDecimalBase &&
               d1.digits_[3] == (1U << (k + 1)) / longint::kDecimalBase);
    }

    {
        d1 = uint32_t{999'999'999};
        d2 = uint64_t{999'999'999'999'999'999ULL};
        d1 += d2;
        assert(d1.digits_.size() == 3 && d1.digits_[0] == 999999998 && d1.digits_[1] == 0 &&
               d1.digits_[2] == 1);
    }

    for (uint32_t i = 0; i <= kC; i++) {
        for (uint32_t j = 0; j <= kC; j++) {
            d1 = i;
            d2 = j;
            d1 *= d2;
            assert(d1 == i * j);
        }
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - kC; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - kC; j != 0; j++) {
            d1 = i;
            d2 = j;
            d1 *= d2;
            assert(d1 == uint64_t{i} * j);
        }
    }

    {
        d1 = static_cast<uint64_t>(1e18);
        static constexpr size_t kInitialZeroLimbs = 2;
        assert(d1.digits_.size() == kInitialZeroLimbs + 1);
        for (size_t i = 0; i < kInitialZeroLimbs; i++) {
            assert(d1.digits_[i] == 0);
        }
        assert(d1.digits_[kInitialZeroLimbs] == 1);

        static constexpr size_t kMults = 20;
        for (size_t i = 0; i < kMults; i++) {
            d1 *= d1;
        }

        static constexpr size_t kNewZeroLimbs = kInitialZeroLimbs << kMults;
        assert(d1.digits_.size() == kNewZeroLimbs + 1);
        for (size_t i = 0; i < kNewZeroLimbs; i++) {
            assert(d1.digits_[i] == 0);
        }
        assert(d1.digits_[kNewZeroLimbs] == 1);
    }

    {
        d1 = uint64_t{1} << 32U;
        assert(d1.digits_.size() == 2);
        assert(d1.digits_[0] == 294967296 && d1.digits_[1] == 4);

        d1 *= d1;
        assert(d1.digits_.size() == 3);
        assert(d1.digits_[0] == 709551616 && d1.digits_[1] == 446744073 && d1.digits_[2] == 18);

        d1 *= d1;
        assert(d1.digits_.size() == 5);
        assert(d1.digits_[0] == 768211456 && d1.digits_[1] == 374607431 &&
               d1.digits_[2] == 938463463 && d1.digits_[3] == 282366920 && d1.digits_[4] == 340);

        d1 *= d1;
        assert(d1.digits_.size() == 9);
        assert(d1.digits_[0] == 129639936 && d1.digits_[1] == 584007913 &&
               d1.digits_[2] == 564039457 && d1.digits_[3] == 984665640 &&
               d1.digits_[4] == 907853269 && d1.digits_[5] == 985008687 &&
               d1.digits_[6] == 195423570 && d1.digits_[7] == 89237316 && d1.digits_[8] == 115792);
    }

    for (uint32_t i = 0; i <= kC; i++) {
        d1 = i;
        d1.square_this_to(d1);
        assert(d1 == i * i);
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - kC; i != 0; i++) {
        d1 = i;
        d1.square_this_to(d1);
        assert(d1 == uint64_t{i} * i);
    }

    {
        d1 = static_cast<uint64_t>(1e18);
        static constexpr size_t kInitialZeroLimbs = 2;
        assert(d1.digits_.size() == kInitialZeroLimbs + 1);
        for (size_t i = 0; i < kInitialZeroLimbs; i++) {
            assert(d1.digits_[i] == 0);
        }
        assert(d1.digits_[kInitialZeroLimbs] == 1);

        static constexpr size_t kMults = 20;
        for (size_t i = 0; i < kMults; i++) {
            d1.square_this_to(d1);
        }

        static constexpr size_t kNewZeroLimbs = kInitialZeroLimbs << kMults;
        assert(d1.digits_.size() == kNewZeroLimbs + 1);
        for (size_t i = 0; i < kNewZeroLimbs; i++) {
            assert(d1.digits_[i] == 0);
        }
        assert(d1.digits_[kNewZeroLimbs] == 1);
    }

    {
        d1 = uint64_t{1} << 32U;
        assert(d1.digits_.size() == 2);
        assert(d1.digits_[0] == 294967296 && d1.digits_[1] == 4);

        d1.square_this_to(d1);
        assert(d1.digits_.size() == 3);
        assert(d1.digits_[0] == 709551616 && d1.digits_[1] == 446744073 && d1.digits_[2] == 18);

        d1.square_this_to(d1);
        assert(d1.digits_.size() == 5);
        assert(d1.digits_[0] == 768211456 && d1.digits_[1] == 374607431 &&
               d1.digits_[2] == 938463463 && d1.digits_[3] == 282366920 && d1.digits_[4] == 340);

        d1.square_this_to(d1);
        assert(d1.digits_.size() == 9);
        assert(d1.digits_[0] == 129639936 && d1.digits_[1] == 584007913 &&
               d1.digits_[2] == 564039457 && d1.digits_[3] == 984665640 &&
               d1.digits_[4] == 907853269 && d1.digits_[5] == 985008687 &&
               d1.digits_[6] == 195423570 && d1.digits_[7] == 89237316 && d1.digits_[8] == 115792);
    }
    {
        d1 = uint64_t{2327846273287647234ULL};
        d2 = uint64_t{3457132687423462ULL};
        assert(d1.digits_.size() == 3);
        assert(d1.digits_[0] == 287647234 && d1.digits_[1] == 327846273 && d1.digits_[2] == 2);
        assert(d2.digits_.size() == 2);
        assert(d2.digits_[0] == 687423462 && d2.digits_[1] == 3457132);
        d1 *= d2;
        assert(d1.digits_.size() == 4);
        assert(d1.digits_[0] == 431004108 && d1.digits_[1] == 644565471 &&
               d1.digits_[2] == 442679614 && d1.digits_[3] == 8047673);
        d2 *= d1;
        assert(d2.digits_.size() == 6);
        assert(d2.digits_[0] == 57581896 && d2.digits_[1] == 950661194 &&
               d2.digits_[2] == 173172305 && d2.digits_[3] == 400547675 &&
               d2.digits_[4] == 874916397 && d2.digits_[5] == 27821);
        d1 *= d2;
        assert(d1.digits_.size() == 10);
        assert(d1.digits_[0] == 722428768 && d1.digits_[1] == 871316001 &&
               d1.digits_[2] == 60383639 && d1.digits_[3] == 98648366 &&
               d1.digits_[4] == 319440946 && d1.digits_[5] == 443692592 &&
               d1.digits_[6] == 814170539 && d1.digits_[7] == 245484337 &&
               d1.digits_[8] == 901363890 && d1.digits_[9] == 223);
        d2 *= d1;
        assert(d2.digits_.size() == 15);
        assert(d2.digits_[0] == 186384128 && d2.digits_[1] == 561145706 &&
               d2.digits_[2] == 972792000 && d2.digits_[3] == 910361576 &&
               d2.digits_[4] == 370236792 && d2.digits_[5] == 997380172 &&
               d2.digits_[6] == 43626094 && d2.digits_[7] == 876538938 &&
               d2.digits_[8] == 838915001 && d2.digits_[9] == 684544134 &&
               d2.digits_[10] == 17528903 && d2.digits_[11] == 739182228 &&
               d2.digits_[12] == 542415704 && d2.digits_[13] == 739765187 &&
               d2.digits_[14] == 6229355);
        d1 *= d2;
        assert(d1.digits_.size() == 25);
        assert(d1.digits_[0] == 965794304 && d1.digits_[1] == 247551591 &&
               d1.digits_[2] == 78766772 && d1.digits_[3] == 645012061 &&
               d1.digits_[4] == 37370453 && d1.digits_[5] == 199399473 &&
               d1.digits_[6] == 955897041 && d1.digits_[7] == 383886055 &&
               d1.digits_[8] == 974981602 && d1.digits_[9] == 715857053 &&
               d1.digits_[10] == 229116146 && d1.digits_[11] == 809476023 &&
               d1.digits_[12] == 335690899 && d1.digits_[13] == 145665659 &&
               d1.digits_[14] == 275922259 && d1.digits_[15] == 152282064 &&
               d1.digits_[16] == 693008292 && d1.digits_[17] == 705711793 &&
               d1.digits_[18] == 145665030 && d1.digits_[19] == 501479354 &&
               d1.digits_[20] == 980999440 && d1.digits_[21] == 357298675 &&
               d1.digits_[22] == 290954608 && d1.digits_[23] == 394761246 && d1.digits_[24] == 1);
    }
}

void TestToIntTypes() {
    test_tools::log_tests_started();
    static constexpr uint32_t kC = 1000000;

    auto test = [n = longint{longint::Reserve{4}}](const auto i) mutable {
        n = i;
        if constexpr (sizeof(i) <= sizeof(uint32_t)) {
            assert(n.fits_in_uint32());
            assert(n.to_uint32() == i);
            const uint32_t j = n;
            assert(j == i);
        }
        if constexpr (sizeof(i) <= sizeof(uint64_t)) {
            assert(n.fits_in_uint64());
            assert(n.to_uint64() == i);
            const uint64_t j = n;
            assert(j == i);
        }
        if constexpr (sizeof(i) <= sizeof(uint128_t)) {
            assert(n.fits_in_uint128());
            assert(n.to_uint128() == i);
            const uint128_t j = n;
            assert(j == i);
        }
        AssertInvariants(n);
    };
    for (uint32_t i = 0; i <= kC; i++) {
        test(i);
    }
    for (uint32_t i = std::numeric_limits<uint32_t>::max() - kC; i != 0; i++) {
        test(i);
    }
    for (uint64_t i = 0; i <= kC; i++) {
        test(i);
    }
    for (uint64_t i = std::numeric_limits<uint64_t>::max() - kC; i != 0; i++) {
        test(i);
    }
    for (uint128_t i = 0; i <= kC; i++) {
        test(i);
    }
    for (uint128_t i = static_cast<uint128_t>(-1) - kC; i != 0; i++) {
        test(i);
    }
}

template <class T, T k>
void TestDivModImpl() {
    test_tools::log_tests_started();

    const auto concat = [](std::vector<T> lhs, const std::vector<T>& rhs) {
        lhs.insert(lhs.end(), rhs.begin(), rhs.end());
        return lhs;
    };

    static_assert(k > 10);

    const auto i_range = [&]() {
        if constexpr (math_functions::is_unsigned_v<T>) {
            return concat(math_functions::arange(T{0}, k + 1),
                          math_functions::arange(std::numeric_limits<T>::max() - k, T{0}));
        } else {
            return math_functions::arange(-k, k + 1);
        }
    }();
    const auto j_range = [&]() {
        if constexpr (math_functions::is_unsigned_v<T>) {
            return concat(math_functions::arange(T{1}, k + 1),
                          math_functions::arange(std::numeric_limits<T>::max() - k, T{0}));
        } else {
            return concat(math_functions::arange(-k, T{0}), math_functions::arange(T{1}, k + 1));
        }
    }();

    auto test_i_j = [n = longint{}, m = longint{}, li_rem = longint{}](const T i,
                                                                       const T j) mutable {
        if constexpr (std::is_same_v<T, uint32_t>) {
            n = i;
            assert(n.mod(j) == i % j);
            const int64_t rem_i_j = n.divmod(j);
            assert(n == i / j);
            assert(rem_i_j == i % j);
            AssertInvariants(n);
        }

        n = i;
        m = j;

        // Test compile time constants
        assert(n.mod(1u) == static_cast<int64_t>(i % 1));
        assert(n.mod(2u) == static_cast<int64_t>(i % 2));
        assert(n.mod(3u) == static_cast<int64_t>(i % 3));

        n.divmod(m, li_rem);
        assert(n == i / j);
        assert(li_rem == i % j);

        AssertInvariants(n);
        AssertInvariants(m);
        AssertInvariants(li_rem);
    };

    for (const T i : i_range) {
        for (const T j : j_range) {
            test_i_j(i, j);
        }
    }
}

void TestDivMod() {
    test_tools::log_tests_started();

    TestDivModImpl<uint32_t, 4000>();
    TestDivModImpl<int32_t, 4000>();
    TestDivModImpl<uint64_t, 4000>();
    TestDivModImpl<int64_t, 4000>();
#if defined(INTEGERS_128_BIT_HPP) && (defined(__GNUG__) || defined(__clang__))
    TestDivModImpl<uint128_t, 4000>();
    TestDivModImpl<int128_t, 4000>();
#endif

    longint n;
    longint m;
    longint rem;
    constexpr std::array<std::string_view, 4> big_ints = {{
        "538714288092043980610037307269667416713870555024102721656419679779374"
        "923813527446566333299023119588532960327655160416672952650552265438069"
        "480844921279178590685230852805810043617124500309990368055562957",
        "290213084194517758966516201644973136574935912430101593678728719207376"
        "239283543794185421070570977723421111953765127658270193387362711172917"
        "254842491555209808089298233500256901159707774581220239792305894702400"
        "718422627848242457771440142125225540017207158668021195884313003164633"
        "568953242740947472813766242520888691791570207128296293932060193742259"
        "027655131589237232055417058854401516386978283594190583849",
        "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"
        "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"
        "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"
        "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"
        "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"
        "99999999999999999999999999999999999999999999999999999999999999",
        "131820409343094310010388979423659136318401916109327276909280345024175692811283445510797521"
        "231721220331409407564807168230384468176942405812817310624525121840385446744443868889563289"
        "706427719939300365865529242495144888321833894158323756200092849226089461110385787540779132"
        "654409185831255860504316472846036364908238500078268116724689002106891044880894853471921527"
        "088201197650061259448583977618746693012787452335047965869945140544352170538037327032402834"
        "008159261693483647994727160945768940072431686625688866030658324868306061250176433564697324"
        "072528745672177336948242366753233417556818392219546938204560720202538843712268268448586361"
        "942128751395665874453900680147479758139717481147704392488266886671292379541285558418744606"
        "657296304926586001793382725791100208812287673612006034789731201688939975743537276539989692"
        "230927982557016660679726989062369216287647728379155260864643891615705346169567037448405029"
        "752790940875872989684235165316260908983893514490200568512210790489667188789433092320719785"
        "756398772086212370409401269127676106581410793787580434036114254547441805771508552049371634"
        "609025127325512605396392214570059772472666763440181556475095153967113514875460624794445927"
        "79055555421362722504575706910949376",
    }};
    for (const std::string_view s : big_ints) {
        n.set_string(s);
        m = n;
        assert(n == m);
        n.divmod(m, rem);
        assert(n == 1);
        assert(rem == 0);
        AssertInvariants(n);
        AssertInvariants(m);
    }
}

}  // namespace

// clang-format off
// NOLINTEND(cert-dcl03-c, misc-static-assert, hicpp-static-assert, cppcoreguidelines-avoid-magic-numbers)
// clang-format on

// NOLINTNEXTLINE(bugprone-exception-escape)
int main() {
    TestSemantic();
    TestOperatorEqualsInt();
    TestToIntTypes();
    TestUIntMult();
    TestUIntAddAndSub();
    TestInt32Div();
    TestLongIntAddAndSub();
    TestLongIntMult();
    TestLongIntSquare();
    TestDivMod();
    TestBitShifts();
    TestDecimal();
    TestSetString();
    TestToString();

    // std::ios::sync_with_stdio(false);
    // std::cin.tie(nullptr);
    // longint n1;
    // longint n2;
    // std::cin >> n1 >> n2;
    // n1 *= n2;
    // std::cout << n1;
    // std::cout.flush();
    // return 0;
}
