#include <chrono>
#include <type_traits>
#include <vector>

#include "config_macros.hpp"
#include "longint.hpp"
#include "test_tools.hpp"

namespace long_int_tests {

namespace {

void AssertInvariants(const longint& n) noexcept {
    static_assert(noexcept(n.size()));
    static_assert(noexcept(n.usize()));
    static_assert(noexcept(n.capacity()));
    static_assert(noexcept(n.begin()));
    static_assert(noexcept(n.end()));
    static_assert(noexcept(n.cbegin()));
    static_assert(noexcept(n.cend()));
    static_assert(noexcept(n.rbegin()));
    static_assert(noexcept(n.rend()));
    static_assert(noexcept(*n.begin()));
    static_assert(noexcept(*n.end()));
    static_assert(noexcept(n.empty()));
    static_assert(noexcept(n.iszero()));
    static_assert(noexcept(static_cast<bool>(n)));
    static_assert(noexcept(!n));
    assert(math_functions::uabs(n.size()) == n.usize());
    assert(n.usize() <= n.capacity());
    assert(n.capacity() <= longint::max_size());
    if (n.empty()) {
        assert(n.size() == 0);
        assert(n.begin() == n.end());
    } else {
        assert(n.size() != 0);
        assert(n.begin() < n.end());
        const auto last_digit = *(n.end() - 1);
        assert(last_digit > 0);
    }
}

void TestOperatorEqualsInt() {
    test_tools::log_tests_started();
    longint n;

    constexpr int32_t K = 150'000;

    n = 0;
    assert(n.sign() == 0);
    assert(n.size() == 0);
    assert(n == 0);
    AssertInvariants(n);
    for (int32_t i = 1; i <= K; i++) {
        n = i;
        assert(n.sign() == 1);
        assert(n.size() == 1 && n.begin()[0] == uint32_t(i));
        assert(n == i);
        assert(n != -i);
        AssertInvariants(n);
    }
    for (int32_t i = -K; i < 0; i++) {
        n = i;
        assert(n.sign() == -1);
        assert(n.size() == -1 && n.begin()[0] == uint32_t(-i));
        assert(n == i);
        assert(n != -i);
        AssertInvariants(n);
    }

    n = 0u;
    assert(n.sign() == 0);
    assert(n.size() == 0);
    assert(n == 0u);
    AssertInvariants(n);
    for (uint32_t i = 1; i <= K; i++) {
        n = i;
        assert(n.sign() == 1);
        assert(n.size() == 1 && n.begin()[0] == i);
        assert(n == i);
        assert(n != -int64_t{i});
        AssertInvariants(n);
    }

    n = int64_t{0};
    assert(n.sign() == 0);
    assert(n.size() == 0);
    assert(n == int64_t{0});
    AssertInvariants(n);
    for (int64_t i = 1; i <= K; i++) {
        n = i;
        assert(n.sign() == 1);
        assert(n.size() == 1 && n.begin()[0] == uint32_t(i));
        assert(n == i);
        assert(n != -i);
        AssertInvariants(n);
    }
    for (int64_t i = -K; i < 0; i++) {
        n = i;
        assert(n.sign() == -1);
        assert(n.size() == -1 && n.begin()[0] == uint32_t(-i));
        assert(n == i);
        assert(n != -i);
        AssertInvariants(n);
    }

    n = uint64_t{0};
    assert(n.sign() == 0);
    assert(n.size() == 0);
    assert(n == uint64_t{0});
    AssertInvariants(n);
    for (uint64_t i = 1; i < K; i++) {
        n = i;
        assert(n.sign() == 1);
        assert(n.size() == 1 && n.begin()[0] == i);
        assert(n == i);
        assert(n != -int128_t{i});
        AssertInvariants(n);
    }

    n = int128_t{0};
    assert(n.sign() == 0);
    assert(n.size() == 0);
    assert(n == int128_t{0});
    AssertInvariants(n);
    for (int64_t i = 1; i <= K; i++) {
        n = int128_t{i};
        assert(n.sign() == 1);
        assert(n.size() == 1 && n.begin()[0] == uint32_t(i));
        assert(n == int128_t{i});
        assert(n != -int128_t{i});
        AssertInvariants(n);
    }
    for (int64_t i = -K; i < 0; i++) {
        n = int128_t{i};
        assert(n.sign() == -1);
        assert(n.size() == -1 && n.begin()[0] == uint32_t(-i));
        assert(n == int128_t{i});
        assert(n != -int128_t{i});
        AssertInvariants(n);
    }

    n = uint128_t{0};
    assert(n.sign() == 0);
    assert(n.size() == 0);
    AssertInvariants(n);
    n = static_cast<uint128_t>(-1);
    assert(n.sign() == 1);
    assert(n.size() == 4);
    assert(n.begin()[0] == std::numeric_limits<uint32_t>::max() &&
           n.begin()[1] == std::numeric_limits<uint32_t>::max() &&
           n.begin()[2] == std::numeric_limits<uint32_t>::max() &&
           n.begin()[3] == std::numeric_limits<uint32_t>::max());
    AssertInvariants(n);

    for (uint64_t i = uint64_t(-1) - K; i != 0; i++) {
        n = i;
        assert(n == i);
        n = uint128_t(i);
        assert(n == uint128_t{i});
        assert(n != -int128_t{i});
        AssertInvariants(n);
    }
    for (uint128_t i = uint128_t(-1) - K; i != 0; i++) {
        n = i;
        assert(n == i);
        assert(n != (i - 1));
        assert(n != (i + 1));
        AssertInvariants(n);
    }
}

void TestLongIntMult() {
    test_tools::log_tests_started();

    longint n1;
    longint n2;
    constexpr uint64_t K = 5000;
    for (uint32_t i = 1; i <= K; i++) {
        for (uint32_t j = 1; j <= K; j++) {
            n1 = i;
            n2 = j;
            assert((n1 < n2) == (i < j));
            n1 *= n2;
            assert(n1 == i * j);
            AssertInvariants(n1);
            AssertInvariants(n2);
        }
    }

    for (uint64_t i = uint64_t(-1) - K; i != 0; i++) {
        for (uint64_t j = uint64_t(-1) - K; j != 0; j++) {
            n1 = uint64_t(i);
            n2 = uint64_t(j);
            assert((n1 < n2) == (i < j));
            n1 *= n2;
            assert(n1 == (uint128_t(i) * uint128_t(j)));
            AssertInvariants(n1);
            AssertInvariants(n2);
        }
    }

    const char* test_cases[][3] = {
        {"0", "0", "0"},
        {"0", "1", "0"},
        {"1", "0", "0"},
        {"0", "99999999999999999999999999999999999999999999999999999999999", "0"},
        {"99999999999999999999999999999999999999999999999999999999999", "0", "0"},
        {"1", "1", "1"},
        {"2", "1", "2"},
        {"1", "2", "2"},
        {"10", "20", "200"},
        {"12", "20", "240"},
        {"1024", "4", "4096"},
        {"12000000", "20000000", "240000000000000"},
        {"13721838", "317826897", "4361169192676686"},
        {"317826897", "13721838", "4361169192676686"},
        {"131241234423234", "5984348957348", "785393344381744834046223432"},
        {"340282367000166625996085689103316680705", "340282367000166625996085689103316680705",
         "115792089291236088776703569810027986869841637790274196431140198001898"
         "919297025"},
        {"273467824687236487236847263874236482736428764827364813231889217390184"
         "829348917249234892378961402352793846723542349823849279432378472893534"
         "9239875",
         "234890218513205634872423783145093845309415709814503975130984759381491"
         "4534715981347589134057893417",
         "642349170971159888904111587665401864943296318873272674206402598998481"
         "144001829012658620088464132921787070037675404241160766315820847757326"
         "085007615660887268742042704088972688871700404868535028458255349812618"
         "7128453709828981195657834716402875"},
        {"952263744", "9359517973", "8912729627004270912"},
        {"4219788824", "2743656178", "11577649676822954672"},
        {"2968434375", "517784556", "1537009474874512500"},
        {"84505427146800725206214423388331447259", "279405665168189620898465228388855751530",
         "236112950822738450044078891891140511945155493452385217141226440086310"
         "03556270"},
        {"241624483789163450827236083147698994361", "176969948248112551859871363564234198810",
         "427602723916451661211499909053727503369996114756759726074868690213215"
         "42910410"},
        {"189745687871346578913675631984859831398756913846314756",
         "23423242342342342342342342345689457967408570698981759840534",
         "444445923042499901900288719235071035985372602038867414228977476967324"
         "0565480827228712761450490207639434131119704"},
        {"23423242342342342342342342345689457967408570698981759840534",
         "189745687871346578913675631984859831398756913846314756",
         "444445923042499901900288719235071035985372602038867414228977476967324"
         "0565480827228712761450490207639434131119704"},
        {"263784627842638746283742347238428746238753489753984753489753895734895"
         "374598347593874590834823942389472893472983472983472984372983742894",
         "217389254359307583476294856287563891627462895613761974651784651756317"
         "561375613856310601356801561875871568715681346134571638145631413008153"
         "301138138",
         "573439435581586836344503148729108267131512809685670894440858871665949"
         "350249919608663834189665543320561328456411904268336709732076203336012"
         "709472247344406733059180011504893572100921001789368036815755131341796"
         "530761123858780924440928033173601703530960115961336341530612366213698"
         "91372"},
        {"497901391203133639584365248205694454191787983065888808021086054694516"
         "231678400769672247210449029211500692922450556195262154964450750615790"
         "589514188335169335767186667337238748906460179043594327975307613550873"
         "497640298659014179164027572907511030105218252598212205594530882278634"
         "877454130119091726705601029352202171195390872242698817060048675435915"
         "135527964210732602071032081196558962307757791960427679399529069324160"
         "549893369013101650049983041135188532935882809944537521495309524288328"
         "855117560004063950897329061825463265670807769803264433240453165419466"
         "124032708997652022855881507054705048360737029012888066511549342858319"
         "594221414437025268041662318574212665165197120587703338083508692868300"
         "677764770579732322663775467094391395549962995658143805157903378864641"
         "845529422222679420854277324025081357759529782057143902526044318608364"
         "773982488660170606054513097933784945464089479906701766065102979875971"
         "016186695987772994526141888182685329927553791394052980374860153388855"
         "6248642308523858954129309895839621",
         "108970620860112407137081415322742626853869366153607749269340200211370"
         "607783690889706401071971517605562911982171828098546334623182361783101"
         "527622674806797503240534309482808265776920525225913147483110997329125"
         "774929345411974578604409416298333424465618343704848658619059126047806"
         "968312617008037576720611676699711149503491022606985517565868797501921"
         "068402587653953249565108588704327397129174524695783763087364999447101"
         "233545982819083696205282296476137023754198789925143561112064292009350"
         "446578133843184706267448822832804838688761964596529899405643175114579"
         "837421411209617498646939693870084669070186947256565085434101186597907"
         "574721562115573828577120603334862160941496987738531194216605182014973"
         "559629133888929125188010648321192064868491615965928704952858784948813"
         "028262472375484232230838139028017592044534551940157817797571827142402"
         "193452406502015912170734287622055641671015226994756461398538648113704"
         "080006243527381200070072950459571659161258052892532223431066903464363"
         "6549786097960658822655773576934232",
         "542566237265191827529937514862954000646132192075670117028672556256875"
         "922981088057291176984953735545161000556996022800239121508505284757162"
         "268909483205498527914555274916168104686152671316244053413629649078592"
         "844221574454571143934298344272998274912039073349090700964702105431117"
         "052463313257026624080682902654613968760291690022965464553805515048545"
         "665814919756077899170782027815231369213297957660369219056733043223216"
         "650840611758386426651922228988776810169486935905786827971524608998934"
         "425480935592871847645329482203292850871800388282012154597553095349607"
         "061204124457639261614130984224601794030397716760678442804462930109239"
         "835200526589104558673734410275262228604661026783817421504731331566088"
         "159708333768459589296158398589645874726780789841965979149435313871784"
         "574855631200841764582159920684861974889545204330460968586302517203122"
         "757973861795664515823524825857550948072156021944827265006595069604640"
         "738609954368159474130242374101753694907633771930949978927315952622963"
         "200910399588310149423264017858244366418817160565161767936461007176434"
         "269452654579036827321940037520503715766834671004963497569735239076366"
         "322219524988756271804939185010822228086674414859379562218488021336743"
         "306279704576159643873067598070257884809075861268963824687803796573476"
         "656878994600856192230007507779855209591502919396895345613654967245608"
         "523561870429177696792471853823824979863659724994067540824448641360311"
         "020227810345973361697859149797441211765701947995273129491616164699781"
         "392550089934232138435257056976549602983289316350764782395107969550665"
         "644683069258104940473930427699017753413415103826696248529241526525773"
         "801855865477090197744456373594926654289133012873441919699920026875851"
         "916411337332255415651235834231397577746492925103509724219067053721769"
         "683258816781174862025112986918398848628743047602431938875162380059549"
         "757320510979602398036873972216468125267715591928946645842024992422856"
         "453314591343472715775836081790421367120745661633730990368643807993416"
         "7085071256457656974379118052493980516605329326027531228264736806072"},
        {"108970620860112407137081415322742626853869366153607749269340200211370"
         "607783690889706401071971517605562911982171828098546334623182361783101"
         "527622674806797503240534309482808265776920525225913147483110997329125"
         "774929345411974578604409416298333424465618343704848658619059126047806"
         "968312617008037576720611676699711149503491022606985517565868797501921"
         "068402587653953249565108588704327397129174524695783763087364999447101"
         "233545982819083696205282296476137023754198789925143561112064292009350"
         "446578133843184706267448822832804838688761964596529899405643175114579"
         "837421411209617498646939693870084669070186947256565085434101186597907"
         "574721562115573828577120603334862160941496987738531194216605182014973"
         "559629133888929125188010648321192064868491615965928704952858784948813"
         "028262472375484232230838139028017592044534551940157817797571827142402"
         "193452406502015912170734287622055641671015226994756461398538648113704"
         "080006243527381200070072950459571659161258052892532223431066903464363"
         "6549786097960658822655773576934232",
         "497901391203133639584365248205694454191787983065888808021086054694516"
         "231678400769672247210449029211500692922450556195262154964450750615790"
         "589514188335169335767186667337238748906460179043594327975307613550873"
         "497640298659014179164027572907511030105218252598212205594530882278634"
         "877454130119091726705601029352202171195390872242698817060048675435915"
         "135527964210732602071032081196558962307757791960427679399529069324160"
         "549893369013101650049983041135188532935882809944537521495309524288328"
         "855117560004063950897329061825463265670807769803264433240453165419466"
         "124032708997652022855881507054705048360737029012888066511549342858319"
         "594221414437025268041662318574212665165197120587703338083508692868300"
         "677764770579732322663775467094391395549962995658143805157903378864641"
         "845529422222679420854277324025081357759529782057143902526044318608364"
         "773982488660170606054513097933784945464089479906701766065102979875971"
         "016186695987772994526141888182685329927553791394052980374860153388855"
         "6248642308523858954129309895839621",
         "542566237265191827529937514862954000646132192075670117028672556256875"
         "922981088057291176984953735545161000556996022800239121508505284757162"
         "268909483205498527914555274916168104686152671316244053413629649078592"
         "844221574454571143934298344272998274912039073349090700964702105431117"
         "052463313257026624080682902654613968760291690022965464553805515048545"
         "665814919756077899170782027815231369213297957660369219056733043223216"
         "650840611758386426651922228988776810169486935905786827971524608998934"
         "425480935592871847645329482203292850871800388282012154597553095349607"
         "061204124457639261614130984224601794030397716760678442804462930109239"
         "835200526589104558673734410275262228604661026783817421504731331566088"
         "159708333768459589296158398589645874726780789841965979149435313871784"
         "574855631200841764582159920684861974889545204330460968586302517203122"
         "757973861795664515823524825857550948072156021944827265006595069604640"
         "738609954368159474130242374101753694907633771930949978927315952622963"
         "200910399588310149423264017858244366418817160565161767936461007176434"
         "269452654579036827321940037520503715766834671004963497569735239076366"
         "322219524988756271804939185010822228086674414859379562218488021336743"
         "306279704576159643873067598070257884809075861268963824687803796573476"
         "656878994600856192230007507779855209591502919396895345613654967245608"
         "523561870429177696792471853823824979863659724994067540824448641360311"
         "020227810345973361697859149797441211765701947995273129491616164699781"
         "392550089934232138435257056976549602983289316350764782395107969550665"
         "644683069258104940473930427699017753413415103826696248529241526525773"
         "801855865477090197744456373594926654289133012873441919699920026875851"
         "916411337332255415651235834231397577746492925103509724219067053721769"
         "683258816781174862025112986918398848628743047602431938875162380059549"
         "757320510979602398036873972216468125267715591928946645842024992422856"
         "453314591343472715775836081790421367120745661633730990368643807993416"
         "7085071256457656974379118052493980516605329326027531228264736806072"},
        {"398745897362857463485376489753649875364854634756893127583461753169476"
         "487536194573741578236174269138178478167188712671340573451475168475768"
         "13468751364056130456875613458136745",
         "348",
         "138763572282274397292911018434270156626969412895398808399044690102977"
         "817662595711662069226188645660086110402181672009626519561113358629567"
         "31087125474691533398992713483431587260"},
        {"348",
         "398745897362857463485376489753649875364854634756893127583461753169476"
         "487536194573741578236174269138178478167188712671340573451475168475768"
         "13468751364056130456875613458136745",
         "138763572282274397292911018434270156626969412895398808399044690102977"
         "817662595711662069226188645660086110402181672009626519561113358629567"
         "31087125474691533398992713483431587260"},
        {"521064401567922879406069432539095585333589848390805645835218385101837"
         "2555735221",
         "521064401567922879406069432539095585333589848390805645835218385101837"
         "2555735221",
         "271508110581337591266374006213668384075074032863180060266512914739142"
         "456172622787686672201433223907591836068343627329838282819700778580870"
         "36385802059859918841"},
        {"398745897362857463485376489753649875364854634756893127583461753169476"
         "487536194573741578236174269138178478167188712671340573451475168475768"
         "13468751364056130456875613458136745",
         "398745897362857463485376489753649875364854634756893127583461753169476"
         "487536194573741578236174269138178478167188712671340573451475168475768"
         "13468751364056130456875613458136745",
         "158998290663710458652907928386102189731894441557379140893911130204468"
         "729629180012082532017682144658368840447283002718093698410970322236959"
         "329738423137118403063843808542333663086419299601252781649552905024490"
         "422756290924999941542817862891684525955199054347881182431401273481363"
         "138211857637015928078713366709245314733667696374248162928864711919502"
         "5"},
        {"538714288092043980610037307269667416713870555024102721656419679779374"
         "923813527446566333299023119588532960327655160416672952650552265438069"
         "480844921279178590685230852805810043617124500309990368055562957",
         "538714288092043980610037307269667416713870555024102721656419679779374"
         "923813527446566333299023119588532960327655160416672952650552265438069"
         "480844921279178590685230852805810043617124500309990368055562957",
         "290213084194517758966516201644973136574935912430101593678728719207376"
         "239283543794185421070570977723421111953765127658270193387362711172917"
         "254842491555209808089298233500256901159707774581220239792305894702400"
         "718422627848242457771440142125225540017207158668021195884313003164633"
         "568953242740947472813766242520888691791570207128296293932060193742259"
         "027655131589237232055417058854401516386978283594190583849"},
        {"378473591711125662205318978307400782427783753923984686802121246042271"
         "316236774444461081305720113769234627500055999892631802251943506510613"
         "041576973905140659553198302268762932232635013075121844024010844209617"
         "001387445367992616947475847556277530823124716511381308443893601036689"
         "835540126414069661052087138994082036710162383386369932806029019860996"
         "789535859361485418449897433469146302768382820057178659536255110169359"
         "845196380565725061526581227067549629866724246482931073170051376781704"
         "197212768365253140559066042002101297055200613269143572019112557085563"
         "899878475510810554198342040963733144408262697470764570314944593526613"
         "934419263025337497357042571717671759023883586867451377168248733405883"
         "910296788303702062215452776471512256941837484725160214833729957202282"
         "648704994064553439348115504885342193852929906418451561210887575546337"
         "507615915632010857173564415901485308965735447198738488397867151647504"
         "526550040119974630239332996345427278593883623686974957277376278631354"
         "869639366838460468748101319039408427701123993442888448154403121426916"
         "704627733981704445112370876108453961872801955347846801218254087739489"
         "562170030806198132295724995482071830436648020515150300468035898691623"
         "269527628850137584131992179304108104221244082970339981314645",
         "242422360745395402404187893934203477400974449065647049988927198970319"
         "805753149705988973274875934705741319528222056518230978113788601185987"
         "597650863481917975147889480918426062465619374716968961931781307592900"
         "017970779362645595784950197534818861618814548119308868190069641017565"
         "582001182178863908348366042579709934563168161190371007834351658980901"
         "439537387725151710448936716057525234422021079168107409249681886185803"
         "656798184787755755302137461956528885902748067318538923549260818296551"
         "459793281096136811002727591059360446183594804912759682504651810130132"
         "241402424826964162913576719514934406842887250631366029807679608779995"
         "452685983217009380013356826166862603999974178446346927185519163124450"
         "042997576507464420018043214571816883931340327689828911413087854407416"
         "013902322113202969761256247555360669534677298033285373411229119624362"
         "114218631744679287995208711756999916330336680306667802886976862157913"
         "540009816489722867943929152313666052647540305002671654304297771170195"
         "703695712037696137032492879795700752067767022685233264574030743197818"
         "202098648173117308846148560570005975871944017411174794281674815109904"
         "233256841885601132453369966630233504941985437823039274173244307950067"
         "942092770927309358035074043249749436812689885822328999166497",
         "917504615823999964812490560695523410616319773621667959556544457902642"
         "228597203892116248150792838436259758633998890742122162662971349908155"
         "647613305941569852250475309540703819614371482131956000579690150103867"
         "335478224759580801158401367416866923388593255048676462217239894005505"
         "009293173974162215718916257677833210773428771087200121260806792118749"
         "401056565747653762978906896044361139468454441915586739520671907037366"
         "061178923181675896266118089995923451280607130137235218424615683169274"
         "638629109230340861539513364511680765354775168309144392850930437629909"
         "540394133815885217123604460615938103773946573454161215645170434248607"
         "885475252350857923430189977279480650126059654087213201630519852181484"
         "420704813284176064997930060799123094778253779356411014104775011619320"
         "890276285350085521042226184089357673933350600306949457583787046722645"
         "223193834579973303690497023431881676046233666783761209898616176106306"
         "729305364655669808769480217965819163342135473082505226302410863190468"
         "064569777465122355280724885358743713689472686982090153578230854097957"
         "195880970282340427948796059589784641830728955991808111545904442719713"
         "968653042471220082243271286370673789701162155117007120303537124233193"
         "275125118972895865679939043604689308535057054691688159958979192970492"
         "683643642024695575369794834267321472216711091276966830924761404911268"
         "187556249989351119873947551162147337246713550069804684687953776739927"
         "160721106545510088122128738416855312105051199067393501114750489112707"
         "303490618722690784630628219351880531189176857749421515617647625613905"
         "992645094759299281495020261468508383302524672961699120310427850850043"
         "608462954117991594441041525615782059524897217309809917382422228775783"
         "745334965416197148513545804017423917503503734483939356285877889547773"
         "524825669114358439184329239325471360281330935188244170013589217201763"
         "068697763253011631858147598565758360894999458452467192507663619987261"
         "612014164670771197354051123684835992187270895966932982720732420678204"
         "203847143455375866973089936570011460388228067165031434155375042497717"
         "403868873136480476131279697289876771903281296615905598206690477049313"
         "392033483312376581841307192363538822368201682123915484751895940728372"
         "363453862818847008212381931201750683359496089644866900948890514635439"
         "499038897053670375385502389269309919840640299039214251339389215673639"
         "932403778057364683711289609946099478058029490734553609251896107587556"
         "209723199428747459201558083692574616874349732490648481890083699349034"
         "17392669574477053593427918093472288422759299448565"},
    };
    for (const char* const(&test)[3] : test_cases) {
        n1.set_string(test[0]);
        n2.set_string(test[1]);
        n1 *= n2;
        n2.set_string(test[2]);
        assert(n1 == n2);
        AssertInvariants(n1);
        AssertInvariants(n2);
    }

    namespace chrono = std::chrono;

    constexpr std::size_t k = std::size_t(1e6);
    std::string s1(k, '9');
    n1.set_string(s1);
    {
        auto start = chrono::high_resolution_clock::now();
        n1 *= n1;
        auto end = chrono::high_resolution_clock::now();
        printf("Multiplied %zu digit numbers in %" PRIu64 " microseconds\n", k,
               uint64_t(chrono::duration_cast<chrono::microseconds>(end - start).count()));
    }
    std::string ans(2 * k, '\0');
    std::memset(ans.data(), '9', (k - 1) * sizeof(char));
    ans[k - 1] = '8';
    std::memset(ans.data() + k, '0', (k - 1) * sizeof(char));
    ans[2 * k - 1] = '1';
    n2.set_string(ans);
    assert(n1 == n2 && "Long test failed");
    AssertInvariants(n1);
    AssertInvariants(n2);
}

void TestLongIntSquare() {
    test_tools::log_tests_started();

    longint n;
    n.reserve(4);
    constexpr uint64_t K = 5000;
    for (uint32_t i = 0; i <= K; i++) {
        n = i;
        n.SquareInplace();
        assert(n == i * i);
        AssertInvariants(n);
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - K; i != 0; i++) {
        n = i;
        n.SquareInplace();
        assert(n == uint64_t(i) * i);
        AssertInvariants(n);
    }

    for (uint64_t i = uint64_t(-1) - K; i != 0; i++) {
        n = i;
        n.SquareInplace();
        assert(n == uint128_t(i) * i);
        AssertInvariants(n);
    }

    for (uint32_t p = 32; p <= 96; p += 32) {
        n = uint128_t(1) << p;
        n.SquareInplace();
        assert(n.size() == int32_t((p + p) / 32 + 1));
        for (std::size_t i = 0; i < (p + p) / 32; i++) {
            assert(n[i] == 0);
        }
        assert(n[(p + p) / 32] == 1);
        AssertInvariants(n);
    }

    n.set_string(
        "5210644015679228794060694325390955853335898483908056458352183851018372"
        "555735221");
    n.SquareInplace();
    longint m(
        "2715081105813375912663740062136683840750740328631800602665129147391424"
        "5617262278768667220143322390759183606834362732983828281970077858087036"
        "385802059859918841");
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);

    n.set_string(
        "3987458973628574634853764897536498753648546347568931275834617531694764"
        "8753619457374157823617426913817847816718871267134057345147516847576813"
        "468751364056130456875613458136745");
    n.SquareInplace();
    m.set_string(
        "1589982906637104586529079283861021897318944415573791408939111302044687"
        "2962918001208253201768214465836884044728300271809369841097032223695932"
        "9738423137118403063843808542333663086419299601252781649552905024490422"
        "7562909249999415428178628916845259551990543478811824314012734813631382"
        "118576370159280787133667092453147336676963742481629288647119195025");
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);

    n.set_string(
        "5387142880920439806100373072696674167138705550241027216564196797793749"
        "2381352744656633329902311958853296032765516041667295265055226543806948"
        "0844921279178590685230852805810043617124500309990368055562957");
    n.SquareInplace();
    m.set_string(
        "2902130841945177589665162016449731365749359124301015936787287192073762"
        "3928354379418542107057097772342111195376512765827019338736271117291725"
        "4842491555209808089298233500256901159707774581220239792305894702400718"
        "4226278482424577714401421252255400172071586680211958843130031646335689"
        "5324274094747281376624252088869179157020712829629393206019374225902765"
        "5131589237232055417058854401516386978283594190583849");
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);

    constexpr std::size_t k = 572;
    std::string long_ten_pow(k + 1, '0');
    long_ten_pow[0] = '1';
    n.set_string(long_ten_pow);
    n.SquareInplace();

    std::string long_ten_pow_square(2 * k + 1, '0');
    long_ten_pow_square[0] = '1';
    m.set_string(long_ten_pow_square);
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);
}

void TestUIntMult() {
    test_tools::log_tests_started();

    longint n;
    constexpr uint64_t K = 5000;
    for (uint64_t i = 0; i <= K; i++) {
        for (uint32_t j = 0; j <= K; j++) {
            n = i;
            n *= j;
            assert(n == i * j);
            AssertInvariants(n);
        }
    }

    for (uint128_t i = (uint128_t(-1) / K) - K; i != (uint128_t(-1) / K); i++) {
        for (uint32_t j = 0; j < K; j++) {
            n = i;
            n *= j;
            assert(n == i * j);
            AssertInvariants(n);
        }
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - K; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n *= uint32_t(j);
            assert(n == uint64_t(i) * uint64_t(j));
            AssertInvariants(n);
        }
    }

    for (uint64_t i = uint64_t(-1) - K; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n *= j;
            assert(n == uint128_t(i) * j);
            AssertInvariants(n);
        }
    }
}

void TestUIntAddAndSub() {
    test_tools::log_tests_started();

    longint n(longint::Reserve(4));
    constexpr uint32_t K = 4000;
    n -= std::numeric_limits<uint32_t>::max();
    assert(n == -int64_t(std::numeric_limits<uint32_t>::max()));
    for (uint32_t i = 0; i <= K; i++) {
        for (uint32_t j = 0; j <= K; j++) {
            n = i;
            n += j;
            assert(n == i + j);
            AssertInvariants(n);
            n = i;
            n -= j;
            if (unlikely(i == j)) {
                assert(!n);
                assert(n.iszero());
            }
            assert(n == int64_t{i} - int64_t{j});
            AssertInvariants(n);
        }
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - K; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == uint64_t{i} + uint64_t{j});
            AssertInvariants(n);
            n = i;
            n -= j;
            if (unlikely(i == j)) {
                assert(!n);
                assert(n.iszero());
            }
            assert(n == int64_t{i} - int64_t{j});
            AssertInvariants(n);
        }
    }

    for (uint64_t i = std::numeric_limits<uint64_t>::max() - K; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == uint128_t{i} + uint128_t{j});
            AssertInvariants(n);
        }
    }

    const uint64_t kStartPos1 = std::numeric_limits<uint64_t>::max();
    for (uint128_t i = kStartPos1; i != uint128_t{kStartPos1} + 2 * K; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == i + j);
            AssertInvariants(n);
        }
    }

    const uint128_t kStartPos2 = uint128_t(-1) / 2;
    for (uint128_t i = kStartPos2 - 2 * K; i != kStartPos2; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == i + j);
            AssertInvariants(n);
        }
    }

    const int32_t kStartPos3 = std::numeric_limits<int32_t>::min();
    for (int32_t i = kStartPos3; i != static_cast<int32_t>(K) + kStartPos3; i++) {
        for (uint32_t j = 0; j <= K; j++) {
            n = i;
            n += j;
            assert(n == i + static_cast<int32_t>(j));
            AssertInvariants(n);
        }
    }

    for (int32_t i = kStartPos3; i != int32_t(K) + kStartPos3; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == i + int64_t{j});
            AssertInvariants(n);
        }
    }

    const int64_t kStartPos4 = -int64_t{1ll << 62};
    for (int64_t i = kStartPos4; i != int64_t{K} + kStartPos4; i++) {
        for (uint32_t j = 0; j <= K; j++) {
            n = i;
            n += j;
            assert(n == i + static_cast<int32_t>(j));
            AssertInvariants(n);
        }
    }

    for (int64_t i = kStartPos4; i != int64_t{K} + kStartPos4; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == i + int64_t{j});
            AssertInvariants(n);
        }
    }

    const int64_t kStartPos5 = std::numeric_limits<int64_t>::min();
    for (int64_t i = kStartPos5; i != int64_t{K} + kStartPos5; i++) {
        for (uint32_t j = 0; j <= K; j++) {
            n = i;
            n += j;
            assert(n == i + static_cast<int32_t>(j));
            AssertInvariants(n);
        }
    }

    for (int64_t i = kStartPos5; i != int64_t{K} + kStartPos5; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n += j;
            assert(n == i + int64_t{j});
            AssertInvariants(n);
        }
    }
}

void TestInt32Div() {
    test_tools::log_tests_started();

    longint n(longint::Reserve(4));
    constexpr uint32_t K = 5000;

    for (uint32_t i = 0; i <= K; i++) {
        for (uint32_t j = 1; j <= K; j++) {
            n = i;
            n /= j;
            assert(n == i / j);
            AssertInvariants(n);
        }

        n = i;
        n /= uint32_t{1} << 0;
        assert(n == i >> 0);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 1;
        assert(n == i >> 1);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 2;
        assert(n == i >> 2);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 15;
        assert(n == i >> 15);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 31;
        assert(n == i >> 31);
    }
    for (uint32_t i = std::numeric_limits<uint32_t>::max() - K; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            n /= j;
            assert(n == i / j);
            AssertInvariants(n);
        }

        n = i;
        n /= uint32_t{1} << 0;
        assert(n == i >> 0);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 1;
        assert(n == i >> 1);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 2;
        assert(n == i >> 2);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 15;
        assert(n == i >> 15);
        AssertInvariants(n);
        n = i;
        n /= uint32_t{1} << 31;
        assert(n == i >> 31);
    }
}

void TestLongIntAddAndSub() {
    test_tools::log_tests_started();
    longint n(longint::Reserve(4));
    longint m(longint::Reserve(4));
    constexpr uint32_t K = 5000;
    for (uint32_t i = 0; i <= K; i++) {
        for (uint32_t j = 1; j <= K; j++) {
            n = i;
            m = j;
            n += m;
            assert(n == i + j);
            AssertInvariants(n);
            n = i;
            n -= m;
            assert(n == int64_t{i} - int64_t{j});
            AssertInvariants(n);
        }
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - K; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            m = j;
            n += m;
            assert(n == i + uint64_t(j));
            AssertInvariants(n);
            n = i;
            n -= m;
            assert(n == int64_t{i} - int64_t(j));
            AssertInvariants(n);
        }
    }

    const auto kStartPos1 =
        std::numeric_limits<uint64_t>::max() - std::numeric_limits<uint32_t>::max();
    for (uint64_t i = kStartPos1 - K; i != kStartPos1; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            m = j;
            n += m;
            assert(n == i + j);
            AssertInvariants(n);
            n = i;
            n -= m;
            assert(n == i - j);
            AssertInvariants(n);
        }
    }

    const auto kStartPos2 = std::numeric_limits<uint64_t>::max();
    for (uint128_t i = kStartPos2; i != uint128_t{kStartPos2} + 2 * K; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - K; j != 0; j++) {
            n = i;
            m = j;
            n += m;
            assert(n == i + j);
            AssertInvariants(n);
            n = i;
            n -= m;
            assert(n == i - j);
            AssertInvariants(n);
        }
    }

    const uint128_t kStartPos3 = uint128_t(-1) / 2;
    for (uint128_t i = kStartPos3 - 2 * K; i < kStartPos3; i++) {
        for (uint128_t j = kStartPos3 - 2 * K; j < kStartPos3; j++) {
            n = i;
            m = j;
            n += m;
            assert(n == i + j);
            AssertInvariants(n);
            n = i;
            n -= m;
            assert(n == static_cast<int64_t>(i - j));
            AssertInvariants(n);
        }
    }
}

void TestSetString() {
    test_tools::log_tests_started();
    constexpr int64_t numbersI64[] = {
        0,
        1,
        -1,
        2,
        -2,
        4,
        -4,
        8,
        -8,
        9,
        -9,
        10,
        -10,
        11,
        -11,
        2147483648,
        -2147483648,
        4294967295,
        -4294967295,
        4294967296,
        -4294967296,
        131241234423234ll,
        5984348957348ll,
        9223372036854775807ll,
        -9223372036854775807ll,
        -9223372036854775807ll - 1,
    };

    longint n;
    for (int64_t number : numbersI64) {
        n.set_string(std::to_string(number));
        assert(n == number);
        AssertInvariants(n);
    }

    constexpr uint64_t numbersU64[] = {
        0,
        1,
        2,
        4,
        8,
        9,
        10,
        11,
        2147483648,
        4294967295,
        4294967296,
        9223372036854775808ull,
        18446744073709551615ull,
    };
    for (uint64_t number : numbersU64) {
        n.set_string(std::to_string(number));
        assert(n == number);
        AssertInvariants(n);
    }

    constexpr uint128_t numbersU128[]{
        0,
        1,
        2,
        4,
        8,
        uint128_t(9999999999) * 10'000'000'000 + 9999999999,
        ((uint128_t(42576258ull) << 64) | uint128_t(9439515947379090504ull)),
        (uint128_t(4581048384968843434ull) << 64) | (uint128_t(15881123738085757915ull)),
        (uint128_t(15146611459005431080ull) << 64) | (uint128_t(11003818173265126250ull)),
        (uint128_t(107408329755340997ull) << 64) | (uint128_t(10118848797326968254ull)),
        (uint128_t(15406421307076602009ull) << 64) | (uint128_t(3266360438134194608ull)),
        (uint128_t(13098489512494978084ull) << 64) | (uint128_t(13194323124312210617ull)),
        (uint128_t(9593560117762545909ull) << 64) | (uint128_t(6883651453229059866ull)),
        (uint128_t(uint64_t(-1)) << 64) | (uint128_t(uint64_t(-1)))};
    for (uint128_t number : numbersU128) {
        n.set_string(to_string(number));
        assert(n == number);
        AssertInvariants(n);
    }

    uint128_t c = 0;
    std::string s;
    s.reserve(39);
    for (std::size_t i = 0; i < 39; i++) {
        n.set_string(s);
        assert(n == c);
        s.push_back('9');
        c = c * 10 + 9;
    }

    // 2^256 - 1
    n.set_string(
        "1157920892373161954235709850086879078532699846656405640394575840079131"
        "29639935");
    std::size_t nums_count;
    nums_count = 256 / (sizeof(uint32_t) * 8);
    assert(n.size() == int32_t(nums_count));
    for (std::size_t i = 0; i < nums_count; i++) {
        assert(n[i] == std::numeric_limits<uint32_t>::max());
    }
    AssertInvariants(n);

    // 2^512 - 1
    n.set_string(
        "1340780792994259709957402499820584612747936582059239337772356144372176"
        "4030073546976801874298166903427690031858186486050853753882811946569946"
        "433649006084095");
    nums_count = 512 / (sizeof(uint32_t) * 8);
    assert(n.size() == int32_t(nums_count));
    for (std::size_t i = 0; i < nums_count; i++) {
        assert(n[i] == std::numeric_limits<uint32_t>::max());
    }
    AssertInvariants(n);
}

void TestToString() {
    test_tools::log_tests_started();
    std::string buffer;

    constexpr int64_t numbersI64[] = {
        0,
        1,
        -1,
        2,
        -2,
        4,
        -4,
        8,
        -8,
        9,
        -9,
        10,
        -10,
        11,
        -11,
        2147483648ll,
        -2147483648ll,
        4294967295ll,
        -4294967295l,
        4294967296ll,
        -4294967296ll,
        131241234423234ll,
        5984348957348ll,
        9223372036854775807ll,
        -9223372036854775807ll,
        -9223372036854775807ll - 1,
    };

    longint n;
    for (int64_t number : numbersI64) {
        n = number;
        n.to_string(buffer);
        assert(buffer == std::to_string(number));
        AssertInvariants(n);
    }

    constexpr uint64_t numbersU64[] = {
        0,
        1,
        2,
        4,
        8,
        9,
        10,
        11,
        2147483648,
        4294967295,
        4294967296,
        9223372036854775808ull,
        18446744073709551615ull,
    };

    for (uint64_t number : numbersU64) {
        n = number;
        n.to_string(buffer);
        assert(buffer == std::to_string(number));
        AssertInvariants(n);
    }

    constexpr uint128_t numbersU128[] = {
        0,
        1,
        2,
        4,
        8,
        ((uint128_t(42576258ull) << 64) | uint128_t(9439515947379090504ull)),
        (uint128_t(4581048384968843434ull) << 64) | (uint128_t(15881123738085757915ull)),
        (uint128_t(15146611459005431080ull) << 64) | (uint128_t(11003818173265126250ull)),
        (uint128_t(107408329755340997ull) << 64) | (uint128_t(10118848797326968254ull)),
        (uint128_t(15406421307076602009ull) << 64) | (uint128_t(3266360438134194608ull)),
        (uint128_t(13098489512494978084ull) << 64) | (uint128_t(13194323124312210617ull)),
        (uint128_t(9593560117762545909ull) << 64) | (uint128_t(6883651453229059866ull)),
        uint128_t(-1)};
    for (uint128_t number : numbersU128) {
        n = number;
        n.to_string(buffer);
        assert(buffer == to_string(number));
        AssertInvariants(n);
    }

    uint128_t c = 0;
    std::string s;
    s.reserve(39);
    buffer.reserve(39);
    n = c;
    n.to_string(buffer);
    assert(buffer.size() == 1 && buffer[0] == '0');
    for (std::size_t i = 0; i < 38; i++) {
        s.push_back('9');
        c = c * 10 + 9;
        n = c;
        assert(n == c);
        n.to_string(buffer);
        assert(buffer == s);
        AssertInvariants(n);
    }

    constexpr std::size_t k             = std::size_t(1e6);
    constexpr std::size_t kSquareDigits = 2 * k;
    n.set_string(std::string(k, '9'));
    n.SquareInplace();
    AssertInvariants(n);

    std::string ans(kSquareDigits, '\0');
    std::memset(ans.data(), '9', (k - 1) * sizeof(char));
    ans[k - 1] = '8';
    std::memset(std::addressof(ans[k]), '0', (k - 1) * sizeof(char));
    ans[kSquareDigits - 1] = '1';

    buffer.reserve(kSquareDigits + 1);
    n.to_string(buffer);
    assert(buffer == ans && "Long int set to_string test failed");

    n.change_sign();
    n.to_string(buffer);
    assert(buffer[0] == '-');
    std::string_view buffer1(&buffer[1], kSquareDigits);
    assert(buffer1 == ans && "Long int set to_string test failed");
    AssertInvariants(n);
}

void TestBitShifts() {
    test_tools::log_tests_started();
    constexpr uint32_t k = 5000;
    longint n;
    n.reserve(4);
    for (uint32_t i = 0; i <= k; i++) {
        for (uint32_t shift = 0; shift <= 31; shift++) {
            n = i;
            n >>= shift;
            assert(n == (i >> shift));
            AssertInvariants(n);
        }
        for (uint32_t j = 0; j <= 16; j++) {
            n = i;
            n >>= 32 + j;
            assert(n == 0);
            AssertInvariants(n);
        }
    }

    for (uint128_t i = uint128_t(-1) - k; i != 0; i++) {
        for (uint32_t shift = 0; shift <= 127; shift++) {
            n = i;
            n >>= shift;
            assert(n == (i >> shift));
            AssertInvariants(n);
        }
        for (uint32_t j = 0; j <= 16; j++) {
            n = i;
            n >>= 128 + j;
            assert(n == 0);
            AssertInvariants(n);
        }
    }

    // 1 << 255
    n.set_string("57896044618658097711785492504343953926634992332820282019728792003956564819968");
    longint m;
    m.reserve(uint32_t(n.usize()));
    AssertInvariants(n);
    for (uint32_t shift = 0; shift <= 127; shift++) {
        m = n;
        m >>= (255 - shift);
        assert(m == uint128_t(1) << shift);
        AssertInvariants(m);
    }

    for (uint32_t r = 0; r <= k; r++) {
        n = 0;
        assert(n.iszero());
        assert(n.sign() == 0);
        assert(n.size() == 0);
        AssertInvariants(n);
        n <<= r;
        assert(n == 0);
        assert(n.iszero());
        assert(n.sign() == 0);
        assert(n.size() == 0);
        AssertInvariants(n);
    }
    for (uint32_t i = 1; i < k; i++) {
        const auto max_k = math_functions::log2_floor(static_cast<uint128_t>(-1) / i);
        for (uint32_t r = 0; r <= max_k; r++) {
            n = i;
            assert(n == i);
            n <<= r;
            assert(n == uint128_t{i} << r);
            assert(n.size() > 0);
            AssertInvariants(n);
        }
    }

    n = 1;
    n <<= 255;
    m.set_string("57896044618658097711785492504343953926634992332820282019728792003956564819968");
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);
    n = 1u;
    n <<= 4000;
    m.set_string(
        "131820409343094310010388979423659136318401916109327276909280345024175692811283445510797521"
        "231721220331409407564807168230384468176942405812817310624525121840385446744443868889563289"
        "706427719939300365865529242495144888321833894158323756200092849226089461110385787540779132"
        "654409185831255860504316472846036364908238500078268116724689002106891044880894853471921527"
        "088201197650061259448583977618746693012787452335047965869945140544352170538037327032402834"
        "008159261693483647994727160945768940072431686625688866030658324868306061250176433564697324"
        "072528745672177336948242366753233417556818392219546938204560720202538843712268268448586361"
        "942128751395665874453900680147479758139717481147704392488266886671292379541285558418744606"
        "657296304926586001793382725791100208812287673612006034789731201688939975743537276539989692"
        "230927982557016660679726989062369216287647728379155260864643891615705346169567037448405029"
        "752790940875872989684235165316260908983893514490200568512210790489667188789433092320719785"
        "756398772086212370409401269127676106581410793787580434036114254547441805771508552049371634"
        "609025127325512605396392214570059772472666763440181556475095153967113514875460624794445927"
        "79055555421362722504575706910949376");
    assert(n == m);
    AssertInvariants(n);
    AssertInvariants(m);

    auto test_compile_time_bit_shifts = [&n, &m](uint64_t i) {
        n = i;
        m = i;
        n /= uint32_t{1} << 0;
        m >>= 0;
        assert(n == m);
        assert(!(n != m));
        assert(n == (i >> 0));
        assert(m == (i >> 0));
        AssertInvariants(n);
        AssertInvariants(m);

        n = i;
        m = i;
        n /= uint32_t{1} << 1;
        m >>= 1;
        assert(n == m);
        assert(!(n != m));
        assert(n == (i >> 1));
        assert(m == (i >> 1));
        AssertInvariants(n);
        AssertInvariants(m);

        n = i;
        m = i;
        n /= uint32_t{1} << 2;
        m >>= 2;
        assert(n == m);
        assert(!(n != m));
        assert(n == (i >> 2));
        assert(m == (i >> 2));
        AssertInvariants(n);
        AssertInvariants(m);

        n = i;
        m = i;
        n /= uint32_t{1} << 15;
        m >>= 15;
        assert(n == m);
        assert(!(n != m));
        assert(n == (i >> 15));
        assert(m == (i >> 15));
        AssertInvariants(n);
        AssertInvariants(m);

        n = i;
        m = i;
        n /= uint32_t{1} << 31;
        m >>= 31;
        assert(n == m);
        assert(!(n != m));
        assert(n == (i >> 31));
        assert(m == (i >> 31));
        AssertInvariants(n);
        AssertInvariants(m);
    };
    for (uint64_t i = 1; i < k; i++) {
        test_compile_time_bit_shifts(i);
    }
    for (uint64_t i = std::numeric_limits<uint32_t>::max() - k; static_cast<uint32_t>(i) != 0;
         i++) {
        test_compile_time_bit_shifts(i);
    }
    for (uint64_t i = std::numeric_limits<uint64_t>::max() - k; i != 0; i++) {
        test_compile_time_bit_shifts(i);
    }
}

void TestDecimal() {
    test_tools::log_tests_started();
    longint::Decimal d1(0u);
    longint::Decimal d2(0u);
    constexpr uint32_t kC = 2500;

    for (uint32_t i = 0; i <= kC; i++) {
        for (uint32_t j = 0; j <= kC; j++) {
            d1 = i;
            d2 = j;
            d1 += d2;
            assert(d1 == i + j);
        }
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - kC; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - kC; j != 0; j++) {
            d1 = i;
            d2 = j;
            d1 += d2;
            assert(d1 == uint64_t(i) + j);
        }
    }

    {
        d1                      = uint64_t(1e18);
        constexpr std::size_t k = 29;
        for (std::size_t i = 0; i < k; i++) {
            d1 += d1;
        }

        assert(d1.size_ == 3 && d1.digits_[0] == 0 && d1.digits_[1] == 0 &&
               d1.digits_[2] == (1 << k));

        d1 += d1;
        assert(d1.size_ == 4 && d1.digits_[0] == 0 && d1.digits_[1] == 0 &&
               d1.digits_[2] == (1u << (k + 1)) % longint::kDecimalBase &&
               d1.digits_[3] == (1u << (k + 1)) / longint::kDecimalBase);
    }

    {
        d1 = uint32_t(999'999'999u);
        d2 = uint64_t(999'999'999'999'999'999ull);
        d1 += d2;
        assert(d1.size_ == 3 && d1.digits_[0] == 999999998 && d1.digits_[1] == 0 &&
               d1.digits_[2] == 1);
    }

    for (uint32_t i = 0; i <= kC; i++) {
        for (uint32_t j = 0; j <= kC; j++) {
            d1 = i;
            d2 = j;
            d1 *= d2;
            assert(d1 == i * j);
        }
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - kC; i != 0; i++) {
        for (uint32_t j = std::numeric_limits<uint32_t>::max() - kC; j != 0; j++) {
            d1 = i;
            d2 = j;
            d1 *= d2;
            assert(d1 == uint64_t{i} * j);
        }
    }

    {
        d1                                      = uint64_t(1e18);
        constexpr std::size_t kInitialZeroLimbs = 2;
        assert(d1.size_ == kInitialZeroLimbs + 1);
        for (std::size_t i = 0; i < kInitialZeroLimbs; i++) {
            assert(d1.digits_[i] == 0);
        }
        assert(d1.digits_[kInitialZeroLimbs] == 1);

        constexpr std::size_t kMults = 20;
        for (std::size_t i = 0; i < kMults; i++) {
            d1 *= d1;
        }

        constexpr std::size_t kNewZeroLimbs = kInitialZeroLimbs << kMults;
        assert(d1.size_ == kNewZeroLimbs + 1);
        for (std::size_t i = 0; i < kNewZeroLimbs; i++) {
            assert(d1.digits_[i] == 0);
        }
        assert(d1.digits_[kNewZeroLimbs] == 1);
    }

    {
        d1 = uint64_t(1) << 32;
        assert(d1.size_ == 2);
        assert(d1.digits_[0] == 294967296 && d1.digits_[1] == 4);

        d1 *= d1;
        assert(d1.size_ == 3);
        assert(d1.digits_[0] == 709551616 && d1.digits_[1] == 446744073 && d1.digits_[2] == 18);

        d1 *= d1;
        assert(d1.size_ == 5);
        assert(d1.digits_[0] == 768211456 && d1.digits_[1] == 374607431 &&
               d1.digits_[2] == 938463463 && d1.digits_[3] == 282366920 && d1.digits_[4] == 340);

        d1 *= d1;
        assert(d1.size_ == 9);
        assert(d1.digits_[0] == 129639936 && d1.digits_[1] == 584007913 &&
               d1.digits_[2] == 564039457 && d1.digits_[3] == 984665640 &&
               d1.digits_[4] == 907853269 && d1.digits_[5] == 985008687 &&
               d1.digits_[6] == 195423570 && d1.digits_[7] == 89237316 && d1.digits_[8] == 115792);
    }

    for (uint32_t i = 0; i <= kC; i++) {
        d1 = i;
        d1.SquareThisTo(d1);
        assert(d1 == i * i);
    }

    for (uint32_t i = std::numeric_limits<uint32_t>::max() - kC; i != 0; i++) {
        d1 = i;
        d1.SquareThisTo(d1);
        assert(d1 == uint64_t(i) * i);
    }

    {
        d1                                      = uint64_t(1e18);
        constexpr std::size_t kInitialZeroLimbs = 2;
        assert(d1.size_ == kInitialZeroLimbs + 1);
        for (std::size_t i = 0; i < kInitialZeroLimbs; i++) {
            assert(d1.digits_[i] == 0);
        }
        assert(d1.digits_[kInitialZeroLimbs] == 1);

        constexpr std::size_t kMults = 20;
        for (std::size_t i = 0; i < kMults; i++) {
            d1.SquareThisTo(d1);
        }

        constexpr std::size_t kNewZeroLimbs = kInitialZeroLimbs << kMults;
        assert(d1.size_ == kNewZeroLimbs + 1);
        for (std::size_t i = 0; i < kNewZeroLimbs; i++) {
            assert(d1.digits_[i] == 0);
        }
        assert(d1.digits_[kNewZeroLimbs] == 1);
    }

    {
        d1 = uint64_t(1) << 32;
        assert(d1.size_ == 2);
        assert(d1.digits_[0] == 294967296 && d1.digits_[1] == 4);

        d1.SquareThisTo(d1);
        assert(d1.size_ == 3);
        assert(d1.digits_[0] == 709551616 && d1.digits_[1] == 446744073 && d1.digits_[2] == 18);

        d1.SquareThisTo(d1);
        assert(d1.size_ == 5);
        assert(d1.digits_[0] == 768211456 && d1.digits_[1] == 374607431 &&
               d1.digits_[2] == 938463463 && d1.digits_[3] == 282366920 && d1.digits_[4] == 340);

        d1.SquareThisTo(d1);
        assert(d1.size_ == 9);
        assert(d1.digits_[0] == 129639936 && d1.digits_[1] == 584007913 &&
               d1.digits_[2] == 564039457 && d1.digits_[3] == 984665640 &&
               d1.digits_[4] == 907853269 && d1.digits_[5] == 985008687 &&
               d1.digits_[6] == 195423570 && d1.digits_[7] == 89237316 && d1.digits_[8] == 115792);
    }
    {
        d1 = uint64_t(2327846273287647234ull);
        d2 = uint64_t(3457132687423462ull);
        assert(d1.size_ == 3);
        assert(d1.digits_[0] == 287647234 && d1.digits_[1] == 327846273 && d1.digits_[2] == 2);
        assert(d2.size_ == 2);
        assert(d2.digits_[0] == 687423462 && d2.digits_[1] == 3457132);
        d1 *= d2;
        assert(d1.size_ == 4);
        assert(d1.digits_[0] == 431004108 && d1.digits_[1] == 644565471 &&
               d1.digits_[2] == 442679614 && d1.digits_[3] == 8047673);
        d2 *= d1;
        assert(d2.size_ == 6);
        assert(d2.digits_[0] == 57581896 && d2.digits_[1] == 950661194 &&
               d2.digits_[2] == 173172305 && d2.digits_[3] == 400547675 &&
               d2.digits_[4] == 874916397 && d2.digits_[5] == 27821);
        d1 *= d2;
        assert(d1.size_ == 10);
        assert(d1.digits_[0] == 722428768 && d1.digits_[1] == 871316001 &&
               d1.digits_[2] == 60383639 && d1.digits_[3] == 98648366 &&
               d1.digits_[4] == 319440946 && d1.digits_[5] == 443692592 &&
               d1.digits_[6] == 814170539 && d1.digits_[7] == 245484337 &&
               d1.digits_[8] == 901363890 && d1.digits_[9] == 223);
        d2 *= d1;
        assert(d2.size_ == 15);
        assert(d2.digits_[0] == 186384128 && d2.digits_[1] == 561145706 &&
               d2.digits_[2] == 972792000 && d2.digits_[3] == 910361576 &&
               d2.digits_[4] == 370236792 && d2.digits_[5] == 997380172 &&
               d2.digits_[6] == 43626094 && d2.digits_[7] == 876538938 &&
               d2.digits_[8] == 838915001 && d2.digits_[9] == 684544134 &&
               d2.digits_[10] == 17528903 && d2.digits_[11] == 739182228 &&
               d2.digits_[12] == 542415704 && d2.digits_[13] == 739765187 &&
               d2.digits_[14] == 6229355);
        d1 *= d2;
        assert(d1.size_ == 25);
        assert(d1.digits_[0] == 965794304 && d1.digits_[1] == 247551591 &&
               d1.digits_[2] == 78766772 && d1.digits_[3] == 645012061 &&
               d1.digits_[4] == 37370453 && d1.digits_[5] == 199399473 &&
               d1.digits_[6] == 955897041 && d1.digits_[7] == 383886055 &&
               d1.digits_[8] == 974981602 && d1.digits_[9] == 715857053 &&
               d1.digits_[10] == 229116146 && d1.digits_[11] == 809476023 &&
               d1.digits_[12] == 335690899 && d1.digits_[13] == 145665659 &&
               d1.digits_[14] == 275922259 && d1.digits_[15] == 152282064 &&
               d1.digits_[16] == 693008292 && d1.digits_[17] == 705711793 &&
               d1.digits_[18] == 145665030 && d1.digits_[19] == 501479354 &&
               d1.digits_[20] == 980999440 && d1.digits_[21] == 357298675 &&
               d1.digits_[22] == 290954608 && d1.digits_[23] == 394761246 && d1.digits_[24] == 1);
    }
}

void TestToIntTypes() {
    test_tools::log_tests_started();
    constexpr uint32_t kC = 1000000;

    longint n(longint::Reserve(4));
    auto test = [&](auto i) {
        n = i;
        if constexpr (sizeof(i) <= sizeof(uint32_t)) {
            assert(n.fits_in_uint32());
            assert(n.to_uint32() == i);
            uint32_t j = n;
            assert(j == i);
        }
        if constexpr (sizeof(i) <= sizeof(uint64_t)) {
            assert(n.fits_in_uint64());
            assert(n.to_uint64() == i);
            uint64_t j = n;
            assert(j == i);
        }
        if constexpr (sizeof(i) <= sizeof(uint128_t)) {
            assert(n.fits_in_uint128());
            assert(n.to_uint128() == i);
            uint128_t j = n;
            assert(j == i);
        }
        AssertInvariants(n);
    };
    for (uint32_t i = 0; i <= kC; i++) {
        test(i);
    }
    for (uint32_t i = std::numeric_limits<uint32_t>::max() - kC; i != 0; i++) {
        test(i);
    }
    for (uint64_t i = 0; i <= kC; i++) {
        test(i);
    }
    for (uint64_t i = uint64_t(-1) - kC; i != 0; i++) {
        test(i);
    }
    for (uint128_t i = 0; i <= kC; i++) {
        test(i);
    }
    for (uint128_t i = uint128_t(-1) - kC; i != 0; i++) {
        test(i);
    }
}

template <class T, T k>
void TestDivModImpl() {
    test_tools::log_tests_started();

    auto concat = [](std::vector<T> lhs, const std::vector<T>& rhs) {
        lhs.insert(lhs.end(), rhs.begin(), rhs.end());
        return lhs;
    };
    static_assert(k > 10);
    const auto i_range = concat(math_functions::arange(T{0}, k + 1),
                                math_functions::arange(std::numeric_limits<T>::max() - k, T{0}));
    const auto j_range = concat(math_functions::arange(T{1}, k + 1),
                                math_functions::arange(std::numeric_limits<T>::max() - k, T{0}));

    auto test_i_j = [n = longint{}, m = longint{}, li_rem = longint{}](const T i,
                                                                       const T j) mutable {
        if constexpr (std::is_same_v<T, uint32_t>) {
            n              = i;
            const auto rem = n.divmod(j);
            assert(n == i / j);
            assert(rem == i % j);
            AssertInvariants(n);
        }

        n = i;
        m = j;
        n.divmod(m, li_rem);
        assert(n == i / j);
        assert(li_rem == i % j);
        AssertInvariants(n);
    };

    for (T i : i_range) {
        for (T j : j_range) {
            test_i_j(i, j);
        }
    }
}

void TestDivMod() {
    test_tools::log_tests_started();
    TestDivModImpl<uint32_t, 6000>();
    TestDivModImpl<uint64_t, 6000>();
    TestDivModImpl<uint128_t, 6000>();

    longint n;
    longint m;
    longint rem;
    constexpr std::string_view big_ints[] = {
        "538714288092043980610037307269667416713870555024102721656419679779374"
        "923813527446566333299023119588532960327655160416672952650552265438069"
        "480844921279178590685230852805810043617124500309990368055562957",
        "290213084194517758966516201644973136574935912430101593678728719207376"
        "239283543794185421070570977723421111953765127658270193387362711172917"
        "254842491555209808089298233500256901159707774581220239792305894702400"
        "718422627848242457771440142125225540017207158668021195884313003164633"
        "568953242740947472813766242520888691791570207128296293932060193742259"
        "027655131589237232055417058854401516386978283594190583849",
        "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"
        "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"
        "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"
        "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"
        "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"
        "99999999999999999999999999999999999999999999999999999999999999",
        "131820409343094310010388979423659136318401916109327276909280345024175692811283445510797521"
        "231721220331409407564807168230384468176942405812817310624525121840385446744443868889563289"
        "706427719939300365865529242495144888321833894158323756200092849226089461110385787540779132"
        "654409185831255860504316472846036364908238500078268116724689002106891044880894853471921527"
        "088201197650061259448583977618746693012787452335047965869945140544352170538037327032402834"
        "008159261693483647994727160945768940072431686625688866030658324868306061250176433564697324"
        "072528745672177336948242366753233417556818392219546938204560720202538843712268268448586361"
        "942128751395665874453900680147479758139717481147704392488266886671292379541285558418744606"
        "657296304926586001793382725791100208812287673612006034789731201688939975743537276539989692"
        "230927982557016660679726989062369216287647728379155260864643891615705346169567037448405029"
        "752790940875872989684235165316260908983893514490200568512210790489667188789433092320719785"
        "756398772086212370409401269127676106581410793787580434036114254547441805771508552049371634"
        "609025127325512605396392214570059772472666763440181556475095153967113514875460624794445927"
        "79055555421362722504575706910949376",
    };
    for (std::string_view s : big_ints) {
        n.set_string(s);
        m = n;
        assert(n == m);
        n.divmod(m, rem);
        assert(n == 1);
        assert(rem == 0);
        AssertInvariants(n);
        AssertInvariants(m);
    }
}

}  // namespace

}  // namespace long_int_tests

int main() {
    using namespace long_int_tests;
    TestOperatorEqualsInt();
    TestToIntTypes();
    TestUIntMult();
    TestUIntAddAndSub();
    TestInt32Div();
    TestLongIntAddAndSub();
    TestLongIntMult();
    TestLongIntSquare();
    TestDivMod();
    TestBitShifts();
    TestDecimal();
    TestSetString();
    TestToString();

    // std::ios::sync_with_stdio(false);
    // std::cin.tie(nullptr);
    // longint n1;
    // longint n2;
    // std::cin >> n1 >> n2;
    // n1 *= n2;
    // std::cout << n1;
    // std::cout.flush();
    // return 0;
}
